<html>
<head>
<title>C++ Annotations Version 9.9.0</title>
</head>
<body text="black" bgcolor="white">
<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus17.html">Previous Chapter</a>
    <li> <a href="cplusplus19.html">Next Chapter</a>
</ul>
<hr>
<a name="STL"></a><a name="l306"></a>
<h1>Chapter 18: The Standard Template Library</h1>

<blockquote>
    <em>
        Don't hesitate to send in feedback: send an e-mail if you like the
        C++ Annotations; if you think that important material was omitted;
        if you find errors or typos in the text or the code examples;
        or if you just feel like e-mailing. Send your e-mail to
        <a href="mailto:f.b.brokken@rug.nl">Frank B. Brokken</a>.
<p>
<strong>Please</strong> state the document version you're referring to, as found in
        the title (in this document: 9.9.0) and please state chapter and
        paragraph name or number you're referring to.
<p>
All received mail is processed conscientiously, and received
        suggestions for improvements are usually processed by the
        time a new version of the Annotations is released. Except for the
        incidental case I will normally not acknowledge the receipt of
        suggestions for improvements. Please don't interpret this as me not
        appreciating your efforts.
    </em>
</blockquote>
<p>
The <a name="an1987"></a><code>Standard Template Library</code> (<a name="an1988"></a>STL) is a general purpose library
consisting of containers, generic algorithms, iterators, function objects,
allocators, adaptors and data structures. The data structures used by the
algorithms are <em>abstract</em> in the sense that the algorithms can be used with
(practically) any data type.
<p>
The algorithms can process these abstract data types because they are
<a name="an1989"></a><em>template</em> based. This chapter does not cover template <em>construction</em>
(see chapter <a href="cplusplus20.html#TEMPLATES">20</a> for that). Rather, it focuses on the <em>use</em>
of the algorithms.
<p>
Several elements also used by the standard template library have already been
discussed in the <strong>C++</strong> Annotations. In chapter <a href="cplusplus12.html#CONTAINERS">12</a> abstract containers
were discussed, and in section <a href="cplusplus11.html#FUNOBJ">11.10</a> function objects were introduced.
Also, <em>iterators</em> were mentioned at several places in this document.
<p>
The main components of the STL are covered in this and the next
chapter. Iterators, adaptors, smart pointers, multi threading and other
features of the STL are discussed in coming sections. Generic
algorithms are covered in the next chapter (<a href="cplusplus19.html#GENERIC">19</a>).
<p>
<em>Allocators</em> take care of the memory allocation within the
STL. The default <a name="an1990"></a>allocator class suffices for most applications, and is
not further discussed in the <strong>C++</strong> Annotations.
<p>
All elements of the STL <a name="an1991"></a> are defined in the
standard namespace. Therefore, a <code>using namespace std</code> or a comparable
directive is required unless it is preferred to specify the required namespace
explicitly. In header files  the <code>std</code> namespace should explicitly
be used (cf. section <a href="cplusplus07.html#NAMESPACEHDR">7.11.1</a>).
<p>
In this chapter the empty <a name="an1992"></a>angle bracket notation is frequently used. In
code a typename must be supplied between the angle brackets. E.g., <code>plus&lt;&gt;</code>
is used in the <strong>C++</strong> Annotations, but in code <code>plus&lt;string&gt;</code> may be encountered.
<p>
<a name="PREDEFINED"></a><a name="l307"></a>
<h2>18.1: Predefined function objects</h2>
Before using the predefined function objects presented in this section the
<a name="an1993"></a><code>&lt;functional&gt;</code> header file must have been included.
<p>
Function objects play important roles in generic
algorithms. For example, there exists a generic algorithm <code>sort</code>
expecting two iterators defining the range of objects that should be sorted,
as well as a function object calling the appropriate comparison operator for
two objects. Let's take a quick look at this situation. Assume strings are
stored in a vector, and we want to sort the vector in descending order. In
that case, sorting the vector <code>stringVec</code> is as simple as:
            <pre>
        sort(stringVec.begin(), stringVec.end(), greater&lt;string&gt;());
</pre>
    The last argument is recognized as a <a name="an1994"></a><em>constructor</em>: it is an
<em>instantiation</em> of the <code>greater&lt;&gt;</code> class template, applied to
<code>strings</code>. This object is called as a function object by the <code>sort</code>
generic algorithm. The generic algorithm calls the function object's
<code>operator()</code> member to compare two <code>string</code> objects. The function object's
<code>operator()</code> will, in turn, call <code>operator&gt;</code> of the <code>string</code> data
type. Eventually, when <code>sort</code> returns, the first element of the vector will
contain the string having the greatest <code>string</code> value of all.
<p>
The function object's <code>operator()</code> itself is <em>not</em> visible at this
point. Don't confuse the parentheses in the `<code>greater&lt;string&gt;()</code>' argument
with calling <code>operator()</code>. When <code>operator()</code> is actually used inside
<code>sort</code>, it receives two arguments: two strings to compare for
`greaterness'. Since <code>greater&lt;string&gt;::operator()</code> is defined <a name="an1995"></a>inline, the
call itself is not actually present in the above <code>sort</code> call.  Instead
<code>sort</code> calls <code>string::operator&gt;</code> through <code>greater&lt;string&gt;::operator()</code>.
<p>
Now that we know that a constructor is passed as argument to (many) generic
algorithms, we can design our own function objects. Assume we want to sort our
vector case-insensitively. How do we proceed? First we note that the default
<code>string::operator&lt;</code> (for an incremental sort) is not appropriate, as it does
case sensitive comparisons. So, we provide our own <code>CaseInsensitive</code> class,
which compares two strings case insensitively. Using the <code>POSIX</code> function
<a name="an1996"></a><code>strcasecmp</code>, the following program performs the trick. It
case-insensitively sorts its command-line arguments in ascending alphabetic
order:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cstring&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    class CaseInsensitive
    {
        public:
            bool operator()(string const &amp;left, string const &amp;right) const
            {
                return strcasecmp(left.c_str(), right.c_str()) &lt; 0;
            }
    };
    int main(int argc, char **argv)
    {
        sort(argv, argv + argc, CaseInsensitive());
        for (int idx = 0; idx &lt; argc; ++idx)
            cout &lt;&lt; argv[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
</pre>
    The default constructor of the <code>class CaseInsensitive</code> is used to
provide <code>sort</code> with its final argument. So the only member function that
must be defined is <code>CaseInsensitive::operator()</code>. Since we know it's called
with <code>string</code> arguments, we define it to expect two <code>string</code> arguments,
which are used when calling <code>strcasecmp</code>. Furthermore, <code>operator()</code>
function is defined <a name="an1997"></a>inline, so that it does not produce overhead when
called by the <code>sort</code> function. The <code>sort</code> function calls the function
object with various combinations of <code>strings</code>. If the compiler grants our
inline requests, it will in fact call <code>strcasecmp</code>, skipping two extra
function calls.
<p>
The comparison function object is often a <a name="an1998"></a><em>predefined function object</em>.
Predefined function object classes are available for many commonly used
operations.  In the following sections the available predefined function
objects are presented, together with some examples showing their use. Near the
end of the section about function objects <a name="an1999"></a><em>function adaptors</em> are
introduced.
<p>
Predefined function objects are used predominantly with generic
algorithms. Predefined function objects exists for arithmetic, relational, and
logical operations. In section <a href="cplusplus23.html#BITFUN">23.3</a> predefined function objects are
developed performing bitwise operations.
<p>
<a name="l308"></a>
<h3>18.1.1: Arithmetic function objects</h3>
    The <a name="an2000"></a><a name="an2001"></a> arithmetic
function objects support the standard <a name="an2002"></a>arithmetic operations: addition,
subtraction, multiplication, division, modulo and negation. These function
objects invoke the corresponding operators of the data types for which they
are instantiated. For example, for addition the function object <code>plus&lt;Type&gt;</code>
<a name="an2003"></a> is available. If we replace <code>Type</code> by <code>size_t</code> then the addition
operator for <code>size_t</code> values is used, if we replace <code>Type</code> by <code>string</code>,
the addition operator for strings is used. For example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        plus&lt;size_t&gt; uAdd;              // function object to add size_ts

        cout &lt;&lt; "3 + 5 = " &lt;&lt; uAdd(3, 5) &lt;&lt; '\n';

        plus&lt;string&gt; sAdd;              // function object to add strings

        cout &lt;&lt; "argv[0] + argv[1] = " &lt;&lt; sAdd(argv[0], argv[1]) &lt;&lt; '\n';
    }
    /*
        Output when called as: a.out going

        3 + 5 = 8
        argv[0] + argv[1] = a.outgoing
    */
</pre>
    Why is this useful? Note that the function object can be used with all
kinds of data types (not only with the predefined datatypes) supporting the
operator called by the function object.
<p>
Suppose we want to perform an operation on a left hand side operand which is
always the same variable and a right hand side argument for which, in turn,
all elements of an array should be used. E.g., we want to compute the sum of
all elements in an array; or we want to concatenate all the strings in a
text-array. In situations like these function objects come in handy.
<p>
As stated, function objects are heavily used in the context of the generic
algorithms, so let's take a quick look ahead at yet another one.
<p>
The generic algorithm <code>accumulate</code> visits all elements specified by an
iterator-range, and performs a requested binary operation on a common element
and each of the elements in the range, returning the accumulated result after
visiting all elements specified by the iterator range. It's easy to use this
algorithm. The next program accumulates all command line arguments and prints
the final string:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;numeric&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        string result =
                accumulate(argv, argv + argc, string(), plus&lt;string&gt;());

        cout &lt;&lt; "All concatenated arguments: " &lt;&lt; result &lt;&lt; '\n';
    }
</pre>
    The first two arguments define the (iterator) range of elements to visit,
the third argument is <code>string</code>. This anonymous string object provides an
initial value. We could also have used
        <pre>
    string("All concatenated arguments: ")
</pre>
    in which case the <code>cout</code> statement could simply have been
<code>cout &lt;&lt; result &lt;&lt; '\n'</code>.
    The string-addition operation is used, called from <code>plus&lt;string&gt;</code>. The
final concatenated string is returned.
<p>
Now we define a class <code>Time</code>, overloading <a name="an2004"></a><code>operator+</code>. Again, we can
apply the predefined function object <code>plus</code>, now tailored to our newly
defined datatype, to add times:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;vector&gt;
    #include &lt;functional&gt;
    #include &lt;numeric&gt;
    using namespace std;

    class Time
    {
        friend ostream &amp;operator&lt;&lt;(ostream &amp;str, Time const &amp;time);
        size_t d_days;
        size_t d_hours;
        size_t d_minutes;
        size_t d_seconds;
        public:
            Time(size_t hours, size_t minutes, size_t seconds);
            Time &amp;operator+=(Time const &amp;rValue);
    };
    Time operator+(Time const &amp;lValue, Time const &amp;rValue)
    {
        Time ret(lValue);
        ret += rValue;
        return ret;
    }
    Time::Time(size_t hours, size_t minutes, size_t seconds)
    :
        d_days(0),
        d_hours(hours),
        d_minutes(minutes),
        d_seconds(seconds)
    {}
    Time &amp;Time::operator+=(Time const &amp;rValue)
    {
        d_seconds   += rValue.d_seconds;
        d_minutes   += rValue.d_minutes   + d_seconds / 60;
        d_hours     += rValue.d_hours     + d_minutes / 60;
        d_days      += rValue.d_days      + d_hours   / 24;
        d_seconds   %= 60;
        d_minutes   %= 60;
        d_hours     %= 24;
        return *this;
    }
    ostream &amp;operator&lt;&lt;(ostream &amp;str, Time const &amp;time)
    {
        return cout &lt;&lt; time.d_days &lt;&lt; " days, " &lt;&lt; time.d_hours &lt;&lt;
                                                    " hours, " &lt;&lt;
                        time.d_minutes &lt;&lt; " minutes and " &lt;&lt;
                        time.d_seconds &lt;&lt; " seconds.";
    }
    int main(int argc, char **argv)
    {
        vector&lt;Time&gt; tvector;

        tvector.push_back(Time( 1, 10, 20));
        tvector.push_back(Time(10, 30, 40));
        tvector.push_back(Time(20, 50,  0));
        tvector.push_back(Time(30, 20, 30));

        cout &lt;&lt;
            accumulate
            (
                tvector.begin(), tvector.end(), Time(0, 0, 0), plus&lt;Time&gt;()
            ) &lt;&lt;
            '\n';
    }
    //  Displays: 2 days, 14 hours, 51 minutes and 30 seconds.
</pre>
    The design of the above program is fairly straightforward.  <code>Time</code>
defines a constructor, it defines an insertion operator and it defines its own
<code>operator+</code>, adding two time objects. In <code>main</code> four <code>Time</code> objects are
stored in a <code>vector&lt;Time&gt;</code> object. Then, <code>accumulate</code> is used to compute
the accumulated time. It returns a <code>Time</code> object, which is inserted into
<code>cout</code>.
<p>
While the first example did show the use of a <em>named</em> function object,
the last two examples showed the use of  <a name="an2005"></a><em>anonymous</em> objects that were
passed to the (<code>accumulate</code>) function.
<p>
The STL supports the following set of arithmetic function objects.  The
function call operator (<code>operator()</code>) of these function objects calls the
matching arithmetic operator for the objects that are passed to the function
call operator, returning that arithmetic operator's return value. The
arithmetic operator that is actually called is mentioned below:
    <ul>
    <li><a name="an2006"></a><code>plus&lt;&gt;</code>: calls the binary <a name="an2007"></a><code>operator+</code>;
    <li><a name="an2008"></a><code>minus&lt;&gt;</code>: calls the binary <a name="an2009"></a><code>operator-</code>;
    <li><a name="an2010"></a><code>multiplies&lt;&gt;</code>: calls the binary <a name="an2011"></a><code>operator*</code>;
    <li><a name="an2012"></a><code>divides&lt;&gt;</code>: calls <a name="an2013"></a><code>operator/</code>;
    <li><a name="an2014"></a><code>modulus&lt;&gt;</code>:  calls <a name="an2015"></a><code>operator%</code>;
    <li><a name="an2016"></a><code>negate&lt;&gt;</code>: calls the unary <code>operator-</code>. This arithmetic
function object is a unary function object as it expects one argument.
    </ul>
    In the next example the <a name="an2017"></a><code>transform</code> generic algorithm is used to toggle
the signs of all elements of an array. <code>Transform</code>
expects two iterators, defining the range of objects to be transformed; an
iterator defining the begin of the destination range (which may be the same
iterator as the first argument); and a function object defining a unary
operation for the indicated data type.
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        int iArr[] = { 1, -2, 3, -4, 5, -6 };

        transform(iArr, iArr + 6, iArr, negate&lt;int&gt;());

        for (int idx = 0; idx &lt; 6; ++idx)
            cout &lt;&lt; iArr[idx] &lt;&lt; ", ";
        cout &lt;&lt; '\n';
    }
    // Displays:  -1, 2, -3, 4, -5, 6,
</pre>
<p>
<a name="l309"></a>
<h3>18.1.2: Relational function objects</h3>
    The relational operators are called by the
 <a name="an2018"></a><a name="an2019"></a> relational
function objects. All standard relational operators are supported: <code>==, !=,
&gt;, &gt;=, &lt;</code> and <code>&lt;=</code>.
<p>
The STL supports the following set of relational function objects.  The
function call operator (<code>operator()</code>) of these function objects calls the
matching relational operator for the objects that are passed to the function
call operator, returning that relational operator's return value. The
relational operator that is actually called is mentioned below:
    <ul>
    <li><a name="an2020"></a><code>equal_to&lt;&gt;</code>: calls <a name="an2021"></a><code>operator==</code>;
    <li><a name="an2022"></a><code>not_equal_to&lt;&gt;</code>: calls <a name="an2023"></a><code>operator!=</code>;
    <li><a name="an2024"></a><code>greater&lt;&gt;</code>: calls <a name="an2025"></a><code>operator&gt;</code>;
    <li><a name="an2026"></a><code>greater_equal&lt;&gt;</code>: calls <a name="an2027"></a><code>operator&gt;=</code>;
    <li><a name="an2028"></a><code>less&lt;&gt;</code>: this object's <code>operator()</code> member calls
        <a name="an2029"></a><code>operator&lt;</code>;
    <li><a name="an2030"></a><code>less_equal&lt;&gt;</code>: calls <a name="an2031"></a><code>operator&lt;=</code>.
    </ul>
    An example using the relational function objects in combination with
<a name="an2032"></a><code>sort</code> is:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        sort(argv, argv + argc, greater_equal&lt;string&gt;());

        for (int idx = 0; idx &lt; argc; ++idx)
            cout &lt;&lt; argv[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';

        sort(argv, argv + argc, less&lt;string&gt;());

        for (int idx = 0; idx &lt; argc; ++idx)
            cout &lt;&lt; argv[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
</pre>
    The example illustrates how strings may be sorted alphabetically and
reversed alphabetically. By passing <code>greater_equal&lt;string&gt;</code> the strings are
sorted in <em>decreasing</em> order (the first word will be the 'greatest'), by
passing <code>less&lt;string&gt;</code> the strings are sorted in <em>increasing</em> order (the
first word will be the 'smallest').
<p>
Note that <code>argv</code> contains <code>char *</code> values, and that the relational
function object expects a <code>string</code>.  The promotion from <code>char const *</code> to
<code>string</code> is silently performed.
<p>
<a name="l310"></a>
<h3>18.1.3: Logical function objects</h3>
    The <a name="an2033"></a>logical operators are called by the
 <a name="an2034"></a><a name="an2035"></a> logical function
objects. The standard logical operators are supported: <code>and, or,</code> and
<code>not</code>.
<p>
The STL supports the following set of logical function objects. The
function call operator (<code>operator()</code>) of these function objects calls the
matching logical operator for the objects that are passed to the function
call operator, returning that logical operator's return value. The
logical operator that is actually called is mentioned below:
    <ul>
    <li><a name="an2036"></a><code>logical_and&lt;&gt;</code>: calls <a name="an2037"></a><code>operator&amp;&amp;</code>;
    <li><a name="an2038"></a><code>logical_or&lt;&gt;</code>: calls <a name="an2039"></a><code>operator||</code>;
    <li><a name="an2040"></a><code>logical_not&lt;&gt;</code>: calls <code>operator!</code>.
    </ul>
    An example using <code>operator!</code> is provided in the following trivial
program, using <a name="an2041"></a><code>transform</code>  to transform
the logicalvalues stored in an array:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;functional&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        bool bArr[] = {true, true, true, false, false, false};
        size_t const bArrSize = sizeof(bArr) / sizeof(bool);

        for (size_t idx = 0; idx &lt; bArrSize; ++idx)
            cout &lt;&lt; bArr[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';

        transform(bArr, bArr + bArrSize, bArr, logical_not&lt;bool&gt;());

        for (size_t idx = 0; idx &lt; bArrSize; ++idx)
            cout &lt;&lt; bArr[idx] &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
    /*
      Displays:

        1 1 1 0 0 0
        0 0 0 1 1 1
    */
</pre>
<p>
<a name="FUNADAPT"></a><a name="l311"></a>
<h3>18.1.4: Function adaptors</h3>
    Function adaptors modify the working of existing function objects. The STL
offers three kinds of <a name="an2042"></a> function adaptors: binders,
negators and member function wrappers. Binders and negators are described in
the next two subsections; member function adaptors are covered in section
<a href="cplusplus19.html#MEMFUNADAPT">19.2</a> of the next chapter, which is a more natural point of
coverage than the current chapter.
<p>
<a name="l312"></a>
<h4>18.1.4.1: Binders</h4>
        <em>Binders</em> <a name="an2043"></a> are function adaptors converting
 <a name="an2044"></a> binary function objects to
 <a name="an2045"></a> unary function objects. They do so by <em>binding</em>
one parameter of a binary function object to a constant value. For example,
the first parameter of the <code>minus&lt;int&gt;</code> function object may be bound to 100,
meaning that the resulting value is always equal to 100 minus the value of the
function object's second argument.
<p>
Either the first or the second parameter may be bound to a specific value. To
bind the constant value to the function object's first parameter the function
adaptor <a name="an2046"></a><code>bind1st</code> is used. To bind the constant value to the function
object's second parameter the function adaptor <a name="an2047"></a><code>bind2nd</code> is used. As an
example, assume we want to count all elements of a vector of <code>string</code>
objects that occur later in the alphabetical ordering than some reference
<code>string</code>.
<p>
The <a name="an2048"></a><code>count_if</code> generic algorithm is the algorithm of choice for solving
these kinds of problems. It expects the usual iterator range and a function
object. However, instead of providing it with a function object it is provided
with the <code>bind2nd</code> adaptor which in turn is initialized with a relational
function object (<code>greater&lt;string&gt;</code>) and a reference string against which all
strings in the iterator range are compared. Here is the required <code>bind2nd</code>
specification:
        <pre>
    bind2nd(greater&lt;string&gt;(), referenceString)
</pre>
    Here is what this binder does:
    <ul>
    <li> To begin with, an adaptor (and so a binder) is a function object, so
it defines <code>operator()</code>. In this case the binder function object is a
<em>unary</em> function object.
    <li> The binder's <code>operator()</code> receives each of the strings referred to
by the iterator range in turn.
    <li> Next it passes these strings and the binder's second argument (the
reference object) to the (binary) <code>operator()</code> defined by the function
object that is passed as the binder's first argument.
    <li> It returns the return value of that latter function object
    </ul>
    Although binders are defined as templates, it is illustrative to have a
look at their implementations, assuming they were ordinary classes. Here is
such a pseudo-implementation of the <code>bind2nd</code> function adaptor:
        <pre>
    class bind2nd
    {
        FunctionObject d_object;
        Operand const &amp;d_operand;
        public:
            bind2nd(FunctionObject const &amp;object, Operand const &amp;operand);
            ReturnType operator()(Operand const &amp;lvalue);
    };
    inline bind2nd::bind2nd(FunctionObject const &amp;object,
                            Operand const &amp;operand)
    :
        d_object(object),
        d_operand(operand)
    {}
    inline ReturnType bind2nd::operator()(Operand const &amp;lvalue)
    {
        return d_object(lvalue, d_operand);
    }
</pre>
    The binder's <code>operator()</code> merely calls the function object's
<code>operator()</code>, providing it with two arguments. It uses its parameter as the
(latter) <code>operator()</code>'s first argument and it uses <code>d_operand</code> as
<code>operator()</code>'s second argument.  The adaptor's members are typically very
small so they are usually implemented inline.
<p>
The above application of the <code>bind2nd</code> adaptor has another important
characteristic. Its return type is identical to the return type of the
function object that it receives as its first argument, which is
<code>bool</code>. Functions <a name="an2049"></a> returning <code>bool</code> values are also
called <em>predicate functions</em>. In the above application the <code>bind2nd</code>
adaptor therefore becomes a predicate function itself.
<p>
The <code>count_if</code> generic algorithm visits all the elements in an iterator
range, returning the number of times the predicate specified as its final
argument returns <a name="an2050"></a><code>true</code>. Each of the elements of the iterator range is
passed to this predicate, which is therefore a unary predicate. Through the
binder the binary function object <code>greater&lt;&gt;</code> is adapted to a unary function
object, that now compares each of the elements referred to by the iterator
range to the reference string.  Eventually, the <code>count_if</code> function is
called like this:
        <pre>
    count_if(stringVector.begin(), stringVector.end(),
             bind2nd(greater&lt;string&gt;(), referenceString));
</pre>
<p>
<a name="l313"></a>
<h4>18.1.4.2: Negators</h4>
        <em>Negators</em> <a name="an2051"></a> are function adaptors converting the values
returned by predicate function. Since there are unary and binary predicate
functions, two <a name="an2052"></a>negator function adaptors were predefined: <a name="an2053"></a><code>not1</code> is
the negator to use with unary predicates, <a name="an2054"></a><code>not2</code> is the negator to
with binary function objects.
<p>
Example: to count the number of persons in a <code>vector&lt;string&gt;</code> vector ordered
alphabetically before (i.e., <em>not</em> exceeding) a certain reference text one
of  the following alternatives could be used:
    <ul>
    <li> a <a name="an2055"></a>binary predicate that directly offers the required comparison:
        <pre>
count_if(stringVector.begin(), stringVector.end(),
    bind2nd(less_equal&lt;string&gt;(), referenceText))
</pre>
    <li> <code>not2</code> in combination  with the <code>greater&lt;&gt;</code> predicate:
        <pre>
count_if(stringVector.begin(), stringVector.end(),
    bind2nd(not2(greater&lt;string&gt;()), referenceText))
</pre>
        Here <code>not2</code> is used as it negates the truth value of a binary
<code>operator()</code>, in this case the <code>greater&lt;string&gt;::operator()</code> member
function.
    <li> <code>not1</code> in combination with the <code>bind2nd</code> predicate:
        <pre>
count_if(stringVector.begin(), stringVector.end(),
    not1(bind2nd(greater&lt;string&gt;(), referenceText)))
</pre>
        Here <code>not1</code> is used as it negates the truth value of a unary
<code>operator()</code>, in this case the <code>bind2nd</code> function adaptor.
    </ul>
    The use of negators is illustrated by the following program:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;functional&gt;
    #include &lt;algorithm&gt;
    #include &lt;vector&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        int iArr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

        cout &lt;&lt; count_if(iArr, iArr + 10, bind2nd(less_equal&lt;int&gt;(), 6)) &lt;&lt;
            ' ';
        cout &lt;&lt; count_if(iArr, iArr + 10, bind2nd(not2(greater&lt;int&gt;()), 6)) &lt;&lt;
            ' ';
        cout &lt;&lt; count_if(iArr, iArr + 10, not1(bind2nd(greater&lt;int&gt;(), 6))) &lt;&lt;
            '\n';
    }
    // Displays: 6 6 6
</pre>
<p>
One may wonder which of these alternative approaches is the faster. Using
the first approach, in which a directly available function object was used,
two actions must be performed for each iteration by <code>count_if</code>:
    <ul>
    <li> The binder's <code>operator()</code> is called;
    <li> The operation <code>&lt;=</code> is performed.
    </ul>
    When the compiler uses inline as requested, only the second step is
actually performed.
<p>
Using the second approach, using the <code>not2</code> negator to
negate the truth value of the complementary logical function object, three
actions must be performed for each iteration by <code>count_if</code>:
    <ul>
    <li> The binder's <code>operator()</code> is called;
    <li> The negator's <code>operator()</code> is called;
    <li> The operation <code>&gt;</code> is performed.
    </ul>
    When the compiler uses inline as requested, only the third step is
actually performed.
<p>
Using the third approach, using <code>not1</code> negator to negate the truth value
of the binder, three actions must be performed for each iteration by
<code>count_if</code>:
    <ul>
    <li> The negator's <code>operator()</code> is called;
    <li> The binder's <code>operator()</code> is called;
    <li> The operation <code>&gt;</code> is performed.
    </ul>
    When the compiler uses inline as requested, only the third step is
actually performed.
<p>
With a commonly used optimization flag like <code>-O2</code> the compiler tries to
grant inline requests. However, if the compiler ignores the inline requests
the first variant will be faster.
<p>
<a name="ITERATORS"></a><a name="l314"></a>
<h2>18.2: Iterators</h2>
In addition to the conceptual iterator types presented in this section the STL
defines several adaptors <a name="an2056"></a> allowing objects to
be passed as iterators. These adaptors are presented in the upcoming
sections. Before those adaptors can be used the <a name="an2057"></a><code>&lt;iterator&gt;</code> header file
must have been included.
<p>
Iterators are objects acting like pointers. Iterators have the following
general  <a name="an2058"></a> characteristics:
    <ul>
    <li> Two iterators may be compared for (in)equality using the <code>==</code> and
<code>!=</code> operators. The <em>ordering</em> operators (e.g., <code>&gt;</code>, <code>&lt;</code>)
can usually not be used.
    <li> Given an iterator <code>iter</code>, <code>*iter</code> represents the object the
iterator points to (alternatively, <code>iter-&gt;</code> can be used to reach the members
of the object the iterator points to).
    <li> <code>++iter</code> or <code>iter++</code> advances the iterator to the next
element. The notion of advancing an iterator to the next element is
consequently applied: several containers support <a name="an2059"></a><em>reversed_iterator</em> types,
in which the <code>++iter</code> operation actually reaches a previous element in a
sequence.
    <li> <em>Pointer arithmetic</em> may be used with iterators of containers
storing their elements consecutively in memory like <a name="an2060"></a><code>vector</code> and
<a name="an2061"></a><code>deque</code>. For such containers <code>iter + 2</code> points to the second element
beyond the one to which <code>iter</code> points.
    <li> Merely defining an iterator is comparable to having a
        0-pointer. Example:
        <pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;

int main()
{
    vector&lt;int&gt;::iterator vi;

    cout &lt;&lt; &amp;*vi;       // prints 0
}
</pre>
    </ul>
    STL containers usually define members offering iterators (i.e., they
define their own type <a name="an2062"></a><code>iterator</code>). These members are commonly called
<a name="an2063"></a><code>begin</code> and <a name="an2064"></a><code>end</code> and (for reversed iterators (type <code>reverse_iterator</code>))
<a name="an2065"></a><code>rbegin</code> and <a name="an2066"></a><code>rend</code>.
<p>
Standard practice requires <a name="an2067"></a> iterator ranges to be
<em>left inclusive</em>.  The notation <a name="an2068"></a><code>[left, right)</code> indicates that <code>left</code>
is an iterator pointing to the first element, while <code>right</code> is an iterator
pointing just <em>beyond</em> the last element. The iterator range is <em>empty</em>
when <code>left == right</code>.
<p>
The following example shows how all elements of a vector of strings can be
inserted into <code>cout</code> using its iterator ranges <code>[begin(), end())</code>, and
<code>[rbegin(), rend())</code>. Note that the <code>for-loops</code> for both ranges are
identical. Furthermore it nicely illustrates how the <code>auto</code> keyword can be
used to define the type of the loop control variable instead of using a much
more verbose variable definition like <code>vector&lt;string&gt;::iterator</code> (see also
section <a href="cplusplus03.html#AUTO">3.3.5</a>):
    <pre>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;string&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        vector&lt;string&gt; args(argv, argv + argc);

        for (auto iter = args.begin(); iter != args.end(); ++iter)
            cout &lt;&lt; *iter &lt;&lt; " ";
        cout &lt;&lt; '\n';

        for (auto iter = args.rbegin(); iter != args.rend(); ++iter)
            cout &lt;&lt; *iter &lt;&lt; " ";
        cout &lt;&lt; '\n';
    }
</pre>
<p>
Furthermore, the STL defines
 <a name="an2069"></a><a name="an2070"></a><em>const_iterator</em> types that must be used
when visiting a series of elements in a constant container. Whereas the
elements of the vector in the previous example could have been altered, the
elements of the vector in the next example are immutable, and
<code>const_iterator</code>s are required:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    #include &lt;string&gt;
    using namespace std;

    int main(int argc, char **argv)
    {
        vector&lt;string&gt; const args(argv, argv + argc);

        for
        (
            vector&lt;string&gt;::const_iterator iter = args.begin();
                iter != args.end();
                    ++iter
        )
            cout &lt;&lt; *iter &lt;&lt; " ";
        cout &lt;&lt; '\n';

        for
        (
            vector&lt;string&gt;::const_reverse_iterator iter = args.rbegin();
                iter != args.rend();
                    ++iter
        )
            cout &lt;&lt; *iter &lt;&lt; " ";
        cout &lt;&lt; '\n';

        return 0;
    }
</pre>
    The examples also illustrates that plain
 <a name="an2071"></a> pointers can be used as iterators. The
initialization <code>vector&lt;string&gt; args(argv, argv + argc)</code> provides the
<code>args</code> vector with a pair of pointer-based iterators: <code>argv</code> points to the
first element to initialize <code>args</code> with, <code>argv + argc</code> points just beyond
the last element to be used, <code>++argv</code> reaches the next command line
argument. This is a general pointer characteristic, which is why they too can
be used in situations where <code>iterators</code> are expected.
<p>
The STL defines five types <a name="an2072"></a> of iterators. These
iterator types are expected by generic algorithms, and in order to create a
particular type of iterator yourself it is important to know their
characteristics. In general, iterators <a name="an2073"></a> (see also
section <a href="cplusplus21.html#ITERATORCONS">21.14</a>) must define:
    <ul>
    <li><a name="an2074"></a><code>operator==</code>, testing two iterators for equality,
    <li><a name="an2075"></a><code>operator!=</code>, testing two iterators for inequality,
    <li><a name="an2076"></a><code>operator++</code>, incrementing the iterator, as prefix operator,
    <li><a name="an2077"></a><code>operator*</code>, to access the element the iterator refers to,
    </ul>
    The following types of iterators are used when describing generic
algorithms  in chapter <a href="cplusplus19.html#GENERIC">19</a>:
    <ul>
    <li> <a name="an2078"></a><strong>InputIterator</strong><strong>s</strong>:
        <blockquote>InputIterators are used to read from a container.  The
dereference operator is guaranteed to work as <a name="an2079"></a><code>rvalue</code> in
expressions. Instead of an InputIterator it is also possible to use (see
below) Forward-, Bidirectional- or RandomAccessIterators.  Notations like
<a name="an2080"></a><code>InputIterator1</code> and <a name="an2081"></a><code>InputIterator2</code> may be used as well. In these cases,
numbers are used to indicate which iterators `belong together'. E.g., the
generic algorithm <a href="cplusplus19.html#INNERPROD"><code>inner_product</code></a> has the following
prototype:
        <pre>
Type inner_product(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, Type init);
</pre>
    <code>InputIterator1 first1</code> and <code>InputIterator1 last1</code> define a pair of
input iterators on one range, while <code>InputIterator2 first2</code> defines the
beginning of another range. Analogous notations may be used with other
iterator types.</blockquote>
    <li> <a name="an2082"></a><strong>OutputIterator</strong><strong>s</strong>:
        <blockquote>OutputIterators can be used to write to a container. The
dereference operator is guaranteed to work as an <a name="an2083"></a><code>lvalue</code> in expressions,
but not necessarily as <code>rvalue</code>. Instead of an OutputIterator it is also
possible to use (see below) Forward-, Bidirectional- or
RandomAccessIterators.</blockquote>
    <li> <a name="an2084"></a><strong>ForwardIterator</strong><strong>s</strong>:
        <blockquote>ForwardIterators combine InputIterators and
OutputIterators. They can be used to traverse containers in one direction,
for reading and/or writing. Instead of a ForwardIterator it is also possible
to use (see below) Bidirectional- or RandomAccessIterators.</blockquote>
    <li> <a name="an2085"></a><strong>BidirectionalIterator</strong><strong>s</strong>:
        <blockquote>BidirectionalIterators can be used to traverse containers in
both directions, for reading and writing. Instead of a BidirectionalIterator
it is also possible to use (see below) a RandomAccessIterator.</blockquote>
    <li> <a name="an2086"></a><strong>RandomAccessIterator</strong><strong>s</strong>:
        <blockquote>RandomAccessIterators provide <a name="an2087"></a>random access to container
elements. An algorithm like <a href="cplusplus19.html#SORT"><code>sort</code></a> requires a
RandomAccessIterator, and can therefore <em>not</em> be used to sort the elements
of lists or maps, which only provide BidirectionalIterators.</blockquote>
    </ul>
    The example given with the RandomAccessIterator illustrates how to relate
iterators and generic algorithms: look for the iterator that's required by the
(generic) algorithm, and then see whether the datastructure supports the
required type of iterator. If not, the algorithm cannot be used with the
particular datastructure.
<p>
<a name="INSERTER"></a><a name="l315"></a>
<h3>18.2.1: Insert iterators</h3>
    Generic algorithms often require a target container into which the results of
the algorithm are deposited. For example, the <a href="cplusplus19.html#COPY"><code>copy</code></a> generic
algorithm has three parameters. The first two define the range of visited
elements, the third defines the first position where the results
of the copy operation should be stored.
<p>
With the <code>copy</code> algorithm the number of elements to copy is usually
available beforehand, since that number can usually be provided by pointer
arithmetic. However, situations exist where pointer arithmetic cannot be
used. Analogously, the number of resulting elements sometimes differs from the
number of elements in the initial range. The generic algorithm
<a href="cplusplus19.html#UNIQUECP"><code>unique_copy</code></a> is a case in point. Here the number of
elements that are copied to the destination container is normally not known
beforehand.
<p>
In situations like these an <a name="an2088"></a><em>inserter</em> <a name="an2089"></a> adaptor
function can often be used to create elements in the destination container.
There are three types of inserter adaptors:
    <ul>
    <li><a name="an2090"></a><code>back_inserter</code>: calls the container's <a name="an2091"></a><code>push_back</code> member to add
new elements at the end of the container. E.g., to copy all elements of
<code>source</code> in reversed order to the back of <code>destination</code>, using the
<a href="cplusplus19.html#COPY"><code>copy</code></a> generic algorithm:
        <pre>
copy(source.rbegin(), source.rend(), back_inserter(destination));
</pre>
    <li><a name="an2092"></a><code>front_inserter</code> calls the container's <a name="an2093"></a><code>push_front</code> member, adding
new elements at the beginning of the container. E.g., to copy all elements of
<code>source</code> to the front of the destination container (thereby also reversing
the order of the elements):
        <pre>
copy(source.begin(), source.end(), front_inserter(destination));
</pre>
    <li><a name="an2094"></a><code>inserter</code> calls the container's <a name="an2095"></a><code>insert</code> member adding new elements
starting at a specified starting point. E.g., to copy all elements of
<code>source</code> to the destination container, starting at the beginning of
<code>destination</code>, shifting up existing elements to beyond the newly inserted
elements:
        <pre>
copy(source.begin(), source.end(), inserter(destination,
    destination.begin()));
</pre>
    </ul>
    The inserter adaptors
 <a name="an2096"></a> <a name="an2097"></a>
 require the existence of two <code>typedef</code>s:
    <ul>
    <li><code>typedef Data value_type</code>, where <code>Data</code> is the data type stored in
the class offering <code>push_back, push_front</code> or <code>insert</code> members (Example:
<code>typedef std::string value_type</code>);
    <li><code>typedef value_type const &amp;const_reference</code>
    </ul>
    Concentrating on <code>back_inserter</code>, this iterator expects the name of a
container supporting a member <code>push_back</code>. The inserter's <code>operator()</code>
member calls the container's <code>push_back</code> member. Objects
 <a name="an2098"></a> of any class supporting a <code>push_back</code>
member can be passed as arguments to <code>back_inserter</code> provided the class adds
        <pre>
    typedef DataType const &amp;const_reference;
</pre>
    to its interface (where <code>DataType const &amp;</code> is the type of the parameter
of the class's member <code>push_back</code>). Example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    using namespace std;

    class Insertable
    {
        public:
            typedef int value_type;
            typedef int const &amp;const_reference;

            void push_back(int const &amp;)
            {}
    };

    int main()
    {
        int arr[] = {1};
        Insertable insertable;

        copy(arr, arr + 1, back_inserter(insertable));
    }
</pre>
<p>
<a name="ISTREAMITERATORS"></a><a name="l316"></a>
<h3>18.2.2: Iterators for `istream' objects</h3>
    The <a name="an2099"></a><code>istream_iterator&lt;Type&gt;</code> can be used to define a set
of iterators for
 <a name="an2100"></a> <code>istream</code> objects. The general form of the
<code>istream_iterator</code> iterator is:
        <pre>
    istream_iterator&lt;Type&gt; identifier(istream &amp;in)
</pre>
    Here, <code>Type</code> is the type of the data elements read from the <code>istream</code>
stream. It is used as the `begin' iterator in an interator range. <code>Type</code> may
be any type for which <code>operator</code>&gt;&gt; is defined in combination with <code>istream</code>
objects.
<p>
The default constructor is used as the end-iterator and corresponds to the
 <a name="an2101"></a>end-of-stream. For example,
        <pre>
    istream_iterator&lt;string&gt; endOfStream;
</pre>
    The <em>stream</em> object that was specified when defining the
begin-iterator is <em>not</em> mentioned with the default constructor.
<p>
Using <code>back_inserter</code> and <code>istream_iterator</code> adaptors, all strings
from a stream can easily be stored in a container. Example (using <a name="an2102"></a>anonymous
<code>istream_iterator</code> adaptors):
        <pre>
    #include &lt;iostream&gt;
    #include &lt;iterator&gt;
    #include &lt;string&gt;
    #include &lt;vector&gt;
    #include &lt;algorithm&gt;
    using namespace std;

    int main()
    {
        vector&lt;string&gt; vs;

        copy(istream_iterator&lt;string&gt;(cin), istream_iterator&lt;string&gt;(),
             back_inserter(vs));

        for
        (
            vector&lt;string&gt;::const_iterator begin = vs.begin(), end = vs.end();
                begin != end; ++begin
        )
            cout &lt;&lt; *begin &lt;&lt; ' ';
        cout &lt;&lt; '\n';
    }
</pre>
<p>
<a name="l317"></a>
<h4>18.2.2.1: Iterators for `istreambuf' objects</h4>
        Input iterators are also available for <a name="an2103"></a><code>streambuf</code> objects.
<p>
To read from <code>streambuf</code> objects supporting input operations
 <a name="an2104"></a><code>istreambuf_iterators</code> can be used, supporting the
operations that are also available for <code>istream_iterator</code>. Different from
the latter iterator type <code>istreambuf_iterators</code> support three constructors:
    <ul>
    <li><code>istreambuf_iterator&lt;Type&gt;</code>:<blockquote>The end iterator of an iterator range is created using the default
<code>istreambuf_iterator</code> constructor. It represents the <a name="an2105"></a>end-of-stream
condition when extracting values of type <code>Type</code> from the <code>streambuf</code>.
        </blockquote>
    <li><code>istreambuf_iterator&lt;Type&gt;(streambuf *)</code>:<blockquote>A pointer to a <code>streambuf</code> may be used when defining an
<code>istreambuf_iterator</code>. It represents the begin iterator of an iterator
range.</blockquote>
    <li><code>istreambuf_iterator&lt;Type&gt;(istream)</code>:<blockquote>An <em>istream</em> may be also used when defining an
<code>istreambuf_iterator</code>. It accesses the <code>istream</code>'s <code>streambuf</code> and it
also represents the begin iterator of an iterator range.</blockquote>
    </ul>
    In section <a href="cplusplus18.html#OSTREAMBUFITER">18.2.3.1</a> an example is given using both
<code>istreambuf_iterators</code> and <code>ostreambuf_iterators</code>.
<p>
<a name="l318"></a>
<h3>18.2.3: Iterators for `ostream' objects</h3>
    An <a name="an2106"></a><code>ostream_iterator&lt;Type&gt;</code> adaptor
can be used to pass an <a name="an2107"></a><code>ostream</code> to algorithms
expecting an OutputIterator. Two constructors are available for defining
<code>ostream_iterators</code>:
        <pre>
    ostream_iterator&lt;Type&gt; identifier(ostream &amp;outStream);
    ostream_iterator&lt;Type&gt; identifier(ostream &amp;outStream, char const *delim);
</pre>
    <code>Type</code> is the type of the data elements that should be inserted into an
<code>ostream</code>. It may be any type for which <code>operator</code>&lt;&lt; is defined in
combinations with <code>ostream</code> objects.  The latter constructor can be used to
separate the individual <code>Type</code> data elements by <a name="an2108"></a><code>delimiter</code> strings. The
former constructor does not use any delimiters.
<p>
The example shows how <a href="cplusplus18.html#ISTREAMITERATORS"><code>istream_iterators</code></a> and an
<code>ostream_iterator</code> may be used to copy information of a file to another
file. A subtlety here is that you probably want to use
<code>in.unsetf(ios::skipws)</code>. It is used to clear the
 <a name="an2109"></a><code>ios::skipws</code> flag. As a consequence white space characters are
simply returned by the operator, and the file is copied character by
character. Here is the program:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        cin.unsetf(ios::skipws);
        copy(istream_iterator&lt;char&gt;(cin), istream_iterator&lt;char&gt;(),
             ostream_iterator&lt;char&gt;(cout));
    }
</pre>
<p>
<a name="OSTREAMBUFITER"></a><a name="l319"></a>
<h4>18.2.3.1: Iterators for `ostreambuf' objects</h4>
        Output iterators are also available for <a name="an2110"></a><code>streambuf</code> objects.
<p>
To write to  <code>streambuf</code> objects supporting output operations
 <a name="an2111"></a><code>ostreambuf_iterators</code> can be used, supporting the
operations that are also available for
<code>ostream_iterator</code>. <code>Ostreambuf_iterators</code> support two constructors:
    <ul>
    <li><code>ostreambuf_iterator&lt;Type&gt;(streambuf *)</code>:<blockquote>A pointer to a <code>streambuf</code> may be used when defining an
<code>ostreambuf_iterator</code>. It can be used as an OutputIterator.</blockquote>
    <li><code>ostreambuf_iterator&lt;Type&gt;(ostream)</code>:<blockquote>An <em>ostream</em> may be also used when defining an
<code>ostreambuf_iterator</code>. It accesses the <code>ostream</code>'s <code>streambuf</code> and it
can also be used as an OutputIterator.</blockquote>
    </ul>
    The next example illustrates the use of both
 <a name="an2112"></a><code>istreambuf_iterators</code> and <code>ostreambuf_iterators</code>
when copying a stream in yet another way. Since the stream's <code>streambuf</code>s
are directly accessed the streams and stream flags are bypassed. Consequently
there is no need to clear <code>ios::skipws</code> as in the previous section, while
the next program's efficiency probably also exceeds the efficiency of the
program shown in the previous section.
        <pre>
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include &lt;iterator&gt;
    using namespace std;

    int main()
    {
        istreambuf_iterator&lt;char&gt; in(cin.rdbuf());
        istreambuf_iterator&lt;char&gt; eof;
        ostreambuf_iterator&lt;char&gt; out(cout.rdbuf());

        copy(in, eof, out);

        return 0;
    }
</pre>
<p>
<a name="UNIQUEPTR"></a><a name="l320"></a>
<h2>18.3: The class 'unique_ptr'</h2>
Before using the <code>unique_ptr</code> class presented in this section the
<a name="an2113"></a><code>&lt;memory&gt;</code> header file must have been included.
<p>
When pointers are used to access dynamically allocated memory strict
bookkeeping is required to prevent memory leaks. When a pointer variable
referring to dynamically allocated memory goes out of scope, the dynamically
allocated memory becomes inaccessible and the program suffers from a 
    <a name="an2114"></a>memory leak.
<p>
To prevent such memory leaks strict bookkeeping is required: the programmer
has to make sure that the dynamically allocated memory is returned to the
common pool just before the pointer variable goes out of scope.
<p>
When a pointer variable points to a dynamically allocated single value or
object, bookkeeping requirements are greatly simplified when the pointer
variable is defined as a <code>std::unique_ptr</code><a name="an2115"></a> object.
<p>
Unique_ptrs are <em>objects</em> masquerading as pointers. Since they are objects,
their destructors are called when they go out of scope.  Their destructors
automatically delete the dynamically allocated memory.
<p>
<code>Unique_ptrs</code> have some special characteristics:
    <ul>
    <li> when assigning a <code>unique_ptr</code> to another <em>move semantics</em> is
used. If move semantics is not available compilation fails. On the other
hand, if compilation succeeds then the used containers or generic algorithms
support the use of <code>unique_ptr</code>s. Here is an example:
        <pre>
std::unique_ptr&lt;int&gt; up1(new int);
std::unique_ptr&lt;int&gt; up2(up1);      // compilation error
</pre>
    The second definition fails to compile as <code>unique_ptr</code>'s copy
constructor is private (the same holds true for the assignment operator). But
the <code>unique_ptr</code> class <em>does</em> offer facilities to initialize and assign
from <em>rvalue references</em>:
        <pre>
class unique_ptr                        // interface partially shown
{
    public:
        unique_ptr(unique_ptr &amp;&amp;other); // rvalues bind here
    private:
        unique_ptr(const unique_ptr &amp;other);
};
</pre>
    In the next example move semantics is used and so it compiles correctly:
        <pre>
unique_ptr&lt;int&gt; cp(unique_ptr&lt;int&gt;(new int));
</pre>
<p>
<li> a <code>unique_ptr</code> object should only point to memory that was made
available dynamically, as only dynamically allocated memory can be deleted.
<p>
<li> multiple <code>unique_ptr</code> objects should not be allowed to point to the
same block of dynamically allocated memory. The <code>unique_ptr</code>'s interface was
designed to prevent this from happening. Once a <code>unique_ptr</code> object goes out
of scope, it deletes the memory it points to, immediately changing any other
object also pointing to the allocated memory into a <a name="an2116"></a> wild
pointer.
<p>
<li> When a class <code>Derived</code> is derived from <code>Base</code>, then a newly
allocated <code>Derived</code> class object can be assigned to a <code>unique_ptr&lt;Base&gt;</code>,
without having to define a virtual destructor for <code>Base</code>. The <code>Base *</code>
pointer that is returned by the <code>unique_ptr</code> object can simply be cast
statically to <code>Derived</code>, as shown in the following example:
        <pre>
    class Base
    { ... };
    class Derived: public Base
    {
        // assume Derived has a member void process()
    };
    int main()
    {
        shared_ptr&lt;Base&gt; bp(new Derived);
        static_cast&lt;Derived *&gt;(bp)-&gt;process(); // OK!

    } // here ~Derived is called: no polymorphism required.
</pre>
    </ul>
    The class <code>unique_ptr</code> offers several member functions to access the
pointer itself or to have a <code>unique_ptr</code> point to another block of
memory. These member functions (and <code>unique_ptr</code> constructors) are
introduced in the next few sections.
<p>
A <code>unique_ptr</code> (as well as a <code>shared_ptr</code>, see section <a href="cplusplus18.html#SHAREDPTR">18.4</a>) can
be used as a safe alternative to the now <a name="an2117"></a> deprecated
<code>auto_ptr</code>. <code>Unique_ptr</code> also augments <code>auto_ptr</code> as it can be used with
containers and (generic) algorithms as it adds customizable deleters. Arrays
can also be handled by <code>unique_ptrs</code>.
<p>
<a name="l321"></a>
<h3>18.3.1: Defining `unique_ptr' objects</h3>
    There are three ways to <a name="an2118"></a> define <code>unique_ptr</code>
objects. Each definition contains the usual <code>&lt;type&gt;</code> specifier between
angle brackets:
    <ul>
    <li> The default constructor simply creates a <code>unique_ptr</code> object that
does not point to a particular block of memory. Its pointer is initialized to
0 (zero):
        <pre>
unique_ptr&lt;type&gt; identifier;
</pre>
    This form is discussed in section <a href="cplusplus18.html#UNIQUEPLAIN">18.3.2</a>.
    <li> The <em>move constructor</em>  initializes an <code>unique_ptr</code> object.
Following the use of the move constructor its <code>unique_ptr</code> argument no
longer points to the dynamically allocated memory and its pointer data member
is turned into a zero-pointer:
        <pre>
unique_ptr&lt;type&gt; identifier(another unique_ptr for type);
</pre>
    This form is discussed in section <a href="cplusplus18.html#UNIQUEMOVE">18.3.3</a>.
    <li> The form that is used most often initializes a <code>unique_ptr</code> object
to the block of dynamically allocated memory that is passed to the object's
constructor. Optionally <a name="an2119"></a><code>deleter</code> can be provided. A (free) function (or
function object) receiving the <code>unique_ptr</code>'s pointer as its argument can be
passed as deleter. It is supposed to return the dynamically allocated
memory to the common pool (doing nothing if the pointer equals zero).
        <pre>
unique_ptr&lt;type&gt; identifier (new-expression [, deleter]);
</pre>
    This form is discussed in section <a href="cplusplus18.html#UNIQUENEW">18.3.4</a>.
    </ul>
<p>
<a name="UNIQUEPLAIN"></a><a name="l322"></a>
<h3>18.3.2: Creating a plain `unique_ptr'</h3>
    <code>Unique_ptr</code>'s default constructor defines a <a name="an2120"></a>
<code>unique_ptr</code> not pointing to a particular block of memory:
        <pre>
    unique_ptr&lt;type&gt; identifier;
</pre>
    The <a name="an2121"></a> pointer controlled by the <code>unique_ptr</code>
object is initialized to <code>0</code> (zero). Although the <code>unique_ptr</code> object
itself is not the pointer, its value <em>can</em> be compared to <code>0</code>. Example:
        <pre>
    unique_ptr&lt;int&gt; ip;

    if (!ip)
        cout &lt;&lt; "0-pointer with a unique_ptr object\n";
</pre>
    Alternatively, the member <a name="an2122"></a><code>get</code> can be used (cf. section <a href="cplusplus18.html#UNIQUEMEM">18.3.5</a>).
<p>
<a name="UNIQUEMOVE"></a><a name="l323"></a>
<h3>18.3.3: Moving  another `unique_ptr'</h3>
        A <code>unique_ptr</code> <a name="an2123"></a> may be initialized
using an rvalue reference to a <code>unique_ptr</code> object for the same type:
        <pre>
    unique_ptr&lt;type&gt; identifier(other unique_ptr object);
</pre>
    The move constructor is used, e.g., in the following example:
        <pre>
    void mover(unique_ptr&lt;string&gt; &amp;&amp;param)
    {
        unique_ptr&lt;string&gt; tmp(move(param));
    }
</pre>
    Analogously, the assignment operator can <a name="an2124"></a> be
used. A <code>unique_ptr</code> object may be assigned to a temporary  <code>unique_ptr</code>
object of the same type (again move-semantics is used). For example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;memory&gt;
    #include &lt;string&gt;

    using namespace std;

    int main()
    {
        unique_ptr&lt;string&gt; hello1(new string("Hello world"));
        unique_ptr&lt;string&gt; hello2(move(hello1));
        unique_ptr&lt;string&gt; hello3;

        hello3 = move(hello2);
        cout &lt;&lt; // *hello1 &lt;&lt; /\n' &lt;&lt;   // would have segfaulted
                // *hello2 &lt;&lt; '\n' &lt;&lt;   // same
                *hello3 &lt;&lt; '\n';
    }
    // Displays:    Hello world
</pre>
    The example illustrates that
    <ul>
    <li> <code>hello1</code> is initialized by a pointer to a dynamically alloctated
<code>string</code> (see the next section).
    <li> The <code>unique_ptr hello2</code> grabs the pointer controlled by <code>hello1</code>
using a move constructor. This effectively changes <code>hello1</code> into a
0-pointer.
    <li> Then <code>hello3</code> is defined as a default <code>unique_ptr&lt;string&gt;</code>. But
then it grabs its value using move-assignment from <code>hello2</code> (which, as a
consequence, is changed into a 0-pointer as well)
    </ul>
    If <code>hello1</code> or <code>hello2</code> had been inserted into <code>cout</code> a
<a name="an2125"></a><em>segmentation fault</em> would have resulted. The reason for this should now be
clear: it is caused by dereferencing 0-pointers. In the end, only <code>hello3</code>
actually points to the originally allocated <code>string</code>.
<p>
<a name="UNIQUENEW"></a><a name="l324"></a>
<h3>18.3.4: Pointing to a newly allocated object</h3>
    A <code>unique_ptr</code> <a name="an2126"></a> is most often initialized
using a pointer to dynamically allocated memory. The generic form is:
        <pre>
    unique_ptr&lt;type [, deleter_type]&gt; identifier(new-expression
            [, deleter = deleter_type()]);
</pre>
    The second (template) argument (<code>deleter(_type)</code>) is optional and may
 <a name="an2127"></a> refer to a free function or function object handling the
destruction of the allocated memory. A deleter is used, e.g., in situations
where a double pointer is allocated and the destruction must visit each nested
pointer to destroy the allocated memory (see below for an illustration).
<p>
Here is an example initializing a <code>unique_ptr</code> pointing to a <code>string</code>
object:
        <pre>
    unique_ptr&lt;string&gt; strPtr(new string("Hello world"));
</pre>
    The argument that is passed to the constructor is the pointer returned by
<code>operator new</code>. Note that <code>type</code> does <em>not</em> mention the pointer.  The
<a name="an2128"></a> type that is used in the <code>unique_ptr</code> construction
is the same as the type that is used in <code>new</code> expressions.
<p>
Here is an example showing how an explicitly defined deleter may be used to
delete a dynamically allocated array of pointers to strings:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;memory&gt;
    using namespace std;

    struct Deleter
    {
        size_t d_size;
        Deleter(size_t size = 0)
        :
            d_size(size)
        {}
        void operator()(string **ptr) const
        {
            for (size_t idx = 0; idx &lt; d_size; ++idx)
                delete ptr[idx];
            delete[] ptr;
        }
    };
    int main()
    {
        unique_ptr&lt;string *, Deleter&gt; sp2(new string *[10], Deleter(10));

        Deleter &amp;obj = sp2.get_deleter();
    }
</pre>
<p>
A <code>unique_ptr</code> can be used to reach the
 <a name="an2129"></a> member functions that are available for
objects allocated by the <code>new</code> expression.  These members can be reached as
if the <code>unique_ptr</code> was a plain pointer to the dynamically allocated
object. For example, in the following program the text `<code>C++</code>' is inserted
behind the word `<code>hello</code>':
        <pre>
    #include &lt;iostream&gt;
    #include &lt;memory&gt;
    #include &lt;cstring&gt;
    using namespace std;

    int main()
    {
        unique_ptr&lt;string&gt; sp(new string("Hello world"));

        cout &lt;&lt; *sp &lt;&lt; '\n';
        sp-&gt;insert(strlen("Hello "), "C++ ");
        cout &lt;&lt; *sp &lt;&lt; '\n';
    }
    /*
        Displays:
            Hello world
            Hello C++ world
    */
</pre>
<p>
<a name="UNIQUEMEM"></a><a name="l325"></a>
<h3>18.3.5: Operators and members</h3>
    The class <code>unique_ptr</code> offers the  following
 <a name="an2130"></a> operators:
    <ul>
    <li><a name="an2131"></a><code>unique_ptr&lt;Type&gt; &amp;operator=(unique_ptr&lt;Type&gt; &amp;&amp;tmp)</code>:<blockquote>This operator transfers the memory pointed to by the <a name="an2132"></a>rvalue
        <code>unique_ptr</code> object to the <a name="an2133"></a>lvalue <code>unique_ptr</code> object using
        <em>move semantics</em>. So, the rvalue object <em>loses</em> the memory it
        pointed at and turns into a 0-pointer. An existing <code>unique_ptr</code> may
        be assigned to another <code>unique_ptr</code> by converting it to an rvalue
        reference first using <a name="an2134"></a><code>std::move</code>. Example:
   <pre>
unique_ptr&lt;int&gt; ip1(new int);
unique_ptr&lt;int&gt; ip2;

ip2 = std::move(ip1);
</pre>
    </blockquote>
    <li><a name="an2135"></a><code>operator bool() const</code>:<blockquote>This operator returns <code>false</code> if the <code>unique_ptr</code> does not point
        to memory (i.e., its <code>get</code> member, see below, returns 0). Otherwise,
        <code>true</code> is returned.</blockquote>
    <li><a name="an2136"></a><code>Type &amp;operator*()</code>:<blockquote>This operator returns a reference to the information accessible via
        a <code>unique_ptr</code> object . It acts like a normal pointer dereference
        operator.</blockquote>
    <li><a name="an2137"></a><code>Type *operator-&gt;()</code>:<blockquote>This operator returns a pointer to the information accessible via a
        <code>unique_ptr</code> object. This operator allows you to select
        members of an object accessible via a <code>unique_ptr</code> object. Example:
   <pre>
unique_ptr&lt;string&gt; sp(new string("hello"));
cout &lt;&lt; sp-&gt;c_str();
</pre>
        </blockquote>
    </ul>
<p>
The class <code>unique_ptr</code> supports the following <a name="an2138"></a>
member functions:
    <ul>
    <li><a name="an2139"></a><code>Type *get()</code>:<blockquote>A pointer to the information controlled by the <code>unique_ptr</code> object
        is returned. It acts like <code>operator-&gt;</code>. The returned pointer can be
        inspected. If it is zero the <code>unique_ptr</code> object does not point to
        any memory.</blockquote>
    <li><a name="an2140"></a><code>Deleter &amp;unique_ptr&lt;Type&gt;::get_deleter()</code>:<blockquote>A reference to the deleter object used by the <code>unique_ptr</code> is
        returned.</blockquote>
    <li><a name="an2141"></a><code>Type *release()</code>:<blockquote>A pointer to the information accessible via a <code>unique_ptr</code> object is
        returned. At the same time the object itself becomes a 0-pointer
        (i.e., its pointer data member is turned into a 0-pointer). This
        member can be used to transfer the information accessible via a
        <code>unique_ptr</code> object to a plain <code>Type</code> pointer. After calling this
        member the proper destruction of the dynamically allocated memory
        is the <a name="an2142"></a>responsibility of the programmer.</blockquote>
    <li><a name="an2143"></a><code>void reset(Type *)</code>:<blockquote>The dynamically allocated memory controlled by the <code>unique_ptr</code>
        object is returned to the common pool; the object thereupon controls
        the memory  to which the argument that is passed to the function
        points. It can also be called without argument, turning the object
        into a 0-pointer. This member function can be used to assign a new
        block of dynamically allocated memory to a <code>unique_ptr</code> object.</blockquote>
    <li><a name="an2144"></a><code>void swap(unique_ptr&lt;Type&gt; &amp;)</code>:<blockquote>Two identically typed <code>unique_ptrs</code> are swapped.</blockquote>
    </ul>
<p>
<a name="l326"></a>
<h3>18.3.6: Using `unique_ptr' objects for arrays</h3>
    When a <code>unique_ptr</code> is used to store arrays the dereferencing operator makes
little sense but with arrays <code>unique_ptr</code> objects benefit from index
operators. The distinction between a single object <code>unique_ptr</code> and a
<code>unique_ptr</code> referring to a dynamically allocated array of objects is
realized through a template specialization.
<p>
With dynamically allocated arrays the following syntax is available:
    <ul>
    <li> the index (<code>[]</code>) notation is used to specify that the smart
        pointer controls a dynamically allocated <em>array</em>. Example:
            <pre>
unique_ptr&lt;int[]&gt; intArr(new int[3]);
</pre>
    <li> the index operator can be used to access the array's
        elements. Example:
            <pre>
intArr[2] = intArr[0];
</pre>
    </ul>
    In these cases the smart pointer's destructors call
<code>delete[]</code> rather than <code>delete</code>.
<p>
<a name="AUTOPTR"></a><a name="l327"></a>
<h3>18.3.7: The legacy class 'auto_ptr' (deprecated)</h3>
    The (now deprecated by the C++11 standard) smart pointer class
<a name="an2145"></a><code>std::auto_ptr&lt;Type&gt;</code> has traditionally been offered by
<strong>C++</strong>. This class does not support <a name="an2146"></a><em>move semantics</em>, but when an
<code>auto_ptr</code> object is assigned to another, the right-hand object loses its
information.
<p>
The class <code>unique_ptr</code> does not have <code>auto_ptr</code>'s drawbacks and
consequently using <code>auto_ptr</code> is now deprecated. <code>Car_ptrs</code> suffer from
the following drawbacks:
    <ul>
    <li> they do not support <em>move semantics</em>;
    <li> they should not be used  to point to arrays;
    <li> they cannot be used as data types of abstract containers.
    </ul>
<p>
Because of its drawbacks and available replacements the <code>auto_ptr</code> class is
no longer covered by the <strong>C++</strong> Annotations. Existing software should be modified
to use smart pointers (<code>unique_ptrs</code> or <code>shared_ptrs</code>) and new software
should, where applicable, directly be implemented in terms of these new smart
pointer types.
<p>
<a name="SHAREDPTR"></a><a name="l328"></a>
<h2>18.4: The class 'shared_ptr'</h2>
In addition to <code>unique_ptr</code> the C++11 standard offers
<a name="an2147"></a><code>std::shared_ptr&lt;Type&gt;</code> which is a reference counting smart
pointer. Before using <code>shared_ptrs</code> the <a name="an2148"></a><code>&lt;memory&gt;</code> header file must have
been included.
<p>
The shared pointer automatically destroys its contents once its reference
count has decayed to zero. As with <code>unique_ptr</code>, when defining a
<code>shared_ptr&lt;Base&gt;</code> to store a newly allocated <code>Derived</code> class object, the
returned <code>Base *</code> may be cast to a <code>Derived *</code> using a <code>static_cast</code>:
polymorphism isn't required, and when resetting the <code>shared_ptr</code> or when the
<code>shared_ptr</code> goes out of scope, no slicing occurs, and <code>Derived</code>'s
destructor is called (cf. section <a href="cplusplus18.html#UNIQUEPTR">18.3</a>).
<p>
<code>Shared_ptr</code>s support copy and move constructors as well as standard and
move overloaded assignment operators.
<p>
Like <code>unique_ptrs, shared_ptrs</code> may refer to dynamically allocated arrays.
<p>
<a name="l329"></a>
<h3>18.4.1: Defining `shared_ptr' objects</h3>
    There are four ways to <a name="an2149"></a> define <code>shared_ptr</code>
objects. Each definition contains the usual <code>&lt;type&gt;</code> specifier between
angle brackets:
    <ul>
    <li> The default constructor simply creates a <code>shared_ptr</code> object that
does not point to a particular block of memory. Its pointer is initialized to
0 (zero):
        <pre>
shared_ptr&lt;type&gt; identifier;
</pre>
    This form is discussed in section <a href="cplusplus18.html#SHAREDPLAIN">18.4.2</a>.
<p>
<li> The copy constructor initializes a <code>shared_ptr</code> so that both
objects share the memory pointed at by the existing object. The copy
constructor also increments the <code>shared_ptr</code>'s reference count. Example:
        <pre>
shared_ptr&lt;string&gt; org(new string("hi there"));
shared_ptr&lt;string&gt; copy(org);   // reference count now 2
</pre>
<p>
<li> The move constructor initializes a <code>shared_ptr</code> with the pointer
and reference count of a temporary <code>shared_ptr</code>. The temporary
<code>shared_ptr</code> is changed into a 0-pointer. An existing <code>shared_ptr</code> may
have its data moved to a newly defined <code>shared_ptr</code> (turning the existing
<code>shared_ptr</code> into a 0-pointer as well). In the next example a temporary,
anonymous <code>shared_ptr</code> object is constructed, which is then used to
construct <code>grabber</code>. Since <code>grabber</code>'s constructor receives an anonymous
temporary object, the compiler uses <code>shared_ptr</code>'s move constructor:
        <pre>
shared_ptr&lt;string&gt; grabber(shared_ptr&lt;string&gt;(new string("hi there")));
</pre>
<p>
<li> The form that is used most often initializes a <code>shared_ptr</code> object
to the block of dynamically allocated memory that is passed to the object's
constructor. Optionally <a name="an2150"></a><code>deleter</code> can be provided. A (free) function (or
function object) receiving the <code>shared_ptr</code>'s pointer as its argument can be
passed as deleter. It is supposed to return the dynamically allocated
memory to the common pool (doing nothing if the pointer equals zero).
        <pre>
shared_ptr&lt;type&gt; identifier (new-expression [, deleter]);
</pre>
    This form is discussed in section <a href="cplusplus18.html#SHAREDNEW">18.4.3</a>.
    </ul>
<p>
<a name="SHAREDPLAIN"></a><a name="l330"></a>
<h3>18.4.2: Creating a plain `shared_ptr'</h3>
    <code>Shared_ptr</code>'s default constructor defines a <a name="an2151"></a>
<code>shared_ptr</code> not pointing to a particular block of memory:
        <pre>
    shared_ptr&lt;type&gt; identifier;
</pre>
    The <a name="an2152"></a> pointer controlled by the <code>shared_ptr</code>
object is initialized to <code>0</code> (zero). Although the <code>shared_ptr</code> object
itself is not the pointer, its value <em>can</em> be compared to <code>0</code>. Example:
        <pre>
    shared_ptr&lt;int&gt; ip;

    if (!ip)
        cout &lt;&lt; "0-pointer with a shared_ptr object\n";
</pre>
    Alternatively, the member <a name="an2153"></a><code>get</code> can be used (cf. section <a href="cplusplus18.html#SHAREDMEM">18.4.4</a>).
<p>
<a name="SHAREDNEW"></a><a name="l331"></a>
<h3>18.4.3: Pointing to a newly allocated object</h3>
    Most often a <code>shared_ptr</code> <a name="an2154"></a> is initialized by a
dynamically allocated block of memory. The generic form is:
        <pre>
    shared_ptr&lt;type&gt; identifier(new-expression [, deleter]);
</pre>
    The second argument (<code>deleter</code>) is optional and
 <a name="an2155"></a> refers to a function object or free function handling the
destruction of the allocated memory. A deleter is used, e.g., in situations
where a double pointer is allocated and the destruction must visit each nested
pointer to destroy the allocated memory (see below for an illustration).  It
is used in situations comparable to those encountered with <code>unique_ptr</code>
(cf. section <a href="cplusplus18.html#UNIQUENEW">18.3.4</a>).
<p>
Here is an example initializing a <code>shared_ptr</code> pointing to a <code>string</code>
object:
        <pre>
    shared_ptr&lt;string&gt; strPtr(new string("Hello world"));
</pre>
    The argument that is passed to the constructor is the pointer returned by
<code>operator new</code>. Note that <code>type</code> does <em>not</em> mention the pointer.  The
<a name="an2156"></a> type that is used in the <code>shared_ptr</code> construction
is the same as the type that is used in <code>new</code> expressions.
<p>
The next example illustrates that two <code>shared_ptrs</code> indeed share their
information. After modifying the information controlled by one of the
objects the information controlled by the other object is modified as well:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;memory&gt;
    #include &lt;cstring&gt;
    using namespace std;

    int main()
    {
        shared_ptr&lt;string&gt; sp(new string("Hello world"));
        shared_ptr&lt;string&gt; sp2(sp);

        sp-&gt;insert(strlen("Hello "), "C++ ");
        cout &lt;&lt; *sp &lt;&lt; '\n' &lt;&lt;
                *sp2 &lt;&lt; '\n';
    }
    /*
        Displays:
            Hello C++ world
            Hello C++ world
    */
</pre>
<p>
<a name="SHAREDMEM"></a><a name="l332"></a>
<h3>18.4.4: Operators and members</h3>
    The class <code>shared_ptr</code> offers the following <a name="an2157"></a>
operators:
    <ul>
    <li><a name="an2158"></a><code>shared_ptr &amp;operator=(shared_ptr&lt;Type&gt; const &amp;other)</code>:<blockquote>Copy assignment: the reference count of the operator's left hand side
        operand is reduced. If the reference count decays to zero the
        dynamically allocated memory controlled by the left hand side operand
        is deleted. Then it shares the information with the operator's
        right hand side operand, incrementing the information's reference
        count.</blockquote>
    <li><a name="an2159"></a><code>shared_ptr &amp;operator=(shared_ptr&lt;Type&gt; &amp;&amp;tmp)</code>:<blockquote>Move assignment: the reference count of the operator's left hand side
        operand is reduced. If the reference count decays to zero the
        dynamically allocated memory controlled by the left hand side operand
        is deleted. Then it grabs the information controlled by the
        operator's right hand side operand which is turned into a 0-pointer.</blockquote>
    <li><a name="an2160"></a><code>operator bool() const</code>:<blockquote>If the <code>shared_ptr</code> actually points to memory <code>true</code> is returned,
        otherwise, <code>false</code> is returned.</blockquote>
    <li><a name="an2161"></a><code>Type &amp;operator*()</code>:<blockquote>A reference to the information stored in the
        <code>shared_ptr</code> object is returned. It acts like a normal pointer.</blockquote>
    <li><a name="an2162"></a><code>Type *operator-&gt;()</code>:<blockquote>A pointer to the information controlled by the <code>shared_ptr</code> object
        is returned. Example:
   <pre>
shared_ptr&lt;string&gt; sp(new string("hello"));
cout &lt;&lt; sp-&gt;c_str() &lt;&lt; '\n';
</pre>
        </blockquote>
    </ul>
<p>
The following <a name="an2163"></a>member function member functions are supported:
    <ul>
    <li><a name="an2164"></a><code>Type *get()</code>:<blockquote>A pointer to the information controlled by the <code>shared_ptr</code> object
        is returned. It acts like <code>operator-&gt;</code>. The returned pointer can be
        inspected. If it is zero the <code>shared_ptr</code> object does not point to
        any memory.</blockquote>
    <li><a name="an2165"></a><code>Deleter &amp;get_deleter()</code>:<blockquote>A reference to the <code>shared_ptr</code>'s deleter (function or function
        object) is returned.</blockquote>
    <li><a name="an2166"></a><code>void reset(Type *)</code>:<blockquote>The reference count of the information controlled by the <code>shared_ptr</code>
        object is reduced and if it decays to zero the memory it points to
        is deleted. Thereafter the
        object's information will refer to the argument that is passed to the
        function, setting its shared count to 1. It can also be called without
        argument, turning the object into a 0-pointer. This member function
        can be used to assign a new block of dynamically allocated memory to a
        <code>shared_ptr</code> object.</blockquote>
      <li><a name="an2167"></a><code>void shared_ptr&lt;Type&gt;::swap(shared_ptr&lt;Type&gt; &amp;&amp;)</code>:<blockquote>Two identically typed <code>shared_ptrs</code> are swapped.</blockquote>
    <li><a name="an2168"></a><code>bool unique() const</code>:<blockquote>If the current object is the only object referring to the memory
        controlled by the object <code>true</code> is returned otherwise (including the
        situation where the object is a 0-pointer) <code>false</code> is returned.</blockquote>
    <li><a name="an2169"></a><code>size_t use_count() const</code>:<blockquote>The number of objects sharing the memory controlled by the object is
        returned.</blockquote>
    </ul>
<p>
<a name="SHAREDCAST"></a><a name="l333"></a>
<h3>18.4.5: Casting shared pointers</h3>
    Be cautious when using standard <strong>C++</strong> style casts in combination with
<code>shared_ptr</code> objects. Consider the following two classes:
        <pre>
    struct Base
    {};
    struct Derived: public Base
    {};
</pre>
<p>
As with <code>unique_ptr</code>, when defining a <code>shared_ptr&lt;Base&gt;</code> to store a
newly allocated <code>Derived</code> class object, the returned <code>Base *</code> may be cast
to a <code>Derived *</code> using a <code>static_cast</code>: polymorphism isn't required, and
when resetting the <code>shared_ptr</code> or when the <code>shared_ptr</code> goes out of
scope, no slicing occurs, and <code>Derived</code>'s destructor is called (cf. section
<a href="cplusplus18.html#UNIQUEPTR">18.3</a>).
<p>
Of course, a <code>shared_ptr&lt;Derived&gt;</code> can easily be defined. Since a
<code>Derived</code> object is also a <code>Base</code> object, a pointer to <code>Derived</code> can
be considered a pointer to <code>Base</code> without using casts, but a <code>static_cast</code>
could be used for force the interpretation of a <code>Derived *</code> to a <code>Base *</code>:
        <pre>
    Derived d;
    static_cast&lt;Base *&gt;(&amp;d);
</pre>
<p>
However, a plain <code>static_cast</code> cannot be used when initializing a shared
pointer to a <code>Base</code> using the <code>get</code> member of a shared pointer to a
<code>Derived</code> object. The following code snipped eventually results in an
attempt to delete the dynamically allocated <code>Base</code> object twice:
        <pre>
    shared_ptr&lt;Derived&gt; sd(new Derived);
    shared_ptr&lt;Base&gt; sb(static_cast&lt;Base *&gt;(sd.get()));
</pre>
    Since <code>sd</code> and <code>sb</code> point at the same object <code>~Base</code> will be called
for the same object when <code>sb</code> goes out of scope and when <code>sd</code> goes out of
scope, resulting in premature termination of the program due to a
 <a name="an2170"></a><em>double free</em> error.
<p>
These errors can be prevented using casts that were specifically designed
for being used with <code>shared_ptrs</code>. These casts use specialized constructors
that create a <code>shared_ptr</code> pointing to memory but shares ownership (i.e.,
a reference count) with an existing <code>shared_ptr</code>. These special casts are:
    <ul>
    <li><a name="an2171"></a><code>std::static_pointer_cast&lt;Base&gt;(std::shared_ptr&lt;Derived&gt; ptr)</code>:<blockquote>A <code>shared_ptr</code> to a <code>Base</code> class object is returned. The returned
<code>shared_ptr</code> refers to the base class portion of the <code>Derived</code> class to
which the <code>shared_ptr&lt;Derived&gt; ptr</code> refers. Example:
        <pre>
shared_ptr&lt;Derived&gt; dp(new Derived());
shared_ptr&lt;Base&gt; bp = static_pointer_cast&lt;Base&gt;(dp);
</pre>
        </blockquote>
<p>
<li><a name="an2172"></a><code>std::const_pointer_cast&lt;Class&gt;(std::shared_ptr&lt;Class const&gt; ptr)</code>:<blockquote>A <code>shared_ptr</code> to a <code>Class</code> class object is returned. The
returned <code>shared_ptr</code> refers to a non-const <code>Class</code> object whereas the
<code>ptr</code> argument refers to a <code>Class const</code> object. Example:
        <pre>
shared_ptr&lt;Derived const&gt; cp(new Derived());
shared_ptr&lt;Derived&gt; ncp = const_pointer_cast&lt;Derived&gt;(cp);
</pre>
        </blockquote>
<p>
<li><a name="an2173"></a><code>std::dynamic_pointer_cast&lt;Derived&gt;(std::shared_ptr&lt;Base&gt; ptr)</code>:<blockquote>A <code>shared_ptr</code> to a <code>Derived</code> class object is returned. The
<code>Base</code> class must have at least one virtual member function, and the class
<code>Derived</code>, inheriting from <code>Base</code> may have overridden <code>Base</code>'s virtual
member(s). The returned <code>shared_ptr</code> refers to a <code>Derived</code> class object if
the dynamic cast from <code>Base *</code> to <code>Derived *</code> succeeded. If the dynamic
cast did not succeed the <code>shared_ptr</code>'s <code>get</code> member returns 0.  Example
(assume <code>Derived</code> and <code>Derived2</code> were derived from <code>Base</code>):
        <pre>
shared_ptr&lt;Base&gt; bp(new Derived());
cout &lt;&lt; dynamic_pointer_cast&lt;Derived&gt;(bp).get() &lt;&lt; ' ' &lt;&lt;
        dynamic_pointer_cast&lt;Derived2&gt;(bp).get() &lt;&lt; '\n';
</pre>
    The first <code>get</code> returns a non-0 pointer value, the second <code>get</code>
returns 0.
        </blockquote>
    </ul>
<p>
<a name="SHAREDARRAY"></a><a name="l334"></a>
<h3>18.4.6: Using `shared_ptr' objects for arrays</h3>
    Different from the <code>unique_ptr</code> class no specialization exists for the
<code>shared_ptr</code> class to handle dynamically allocated arrays of objects.
<p>
But like <code>unique_ptrs</code>, with <code>shared_ptrs</code> referring to arrays the
dereferencing operator makes little sense while in these circumstances
<code>shared_ptr</code> objects would benefit from index operators.
<p>
It is not difficult to create a class <code>shared_array</code> offering such
facilities. The class template <code>shared_array</code>, derived from <code>shared_ptr</code>
merely should provide an appropriate <em>deleter</em> to make sure that the array
and its elements are properly destroyed. In addition it should define the
index operator and optionally could declare the derefencing operators using
<code>delete</code>.
<p>
Here is an example showing how <code>shared_array</code> can be defined and used:
            <pre>
    struct X
    {
        ~X()
        {
            cout &lt;&lt; "destr\n";  // show the object's destruction
        }
    };
    template &lt;typename Type&gt;
    class shared_array: public shared_ptr&lt;Type&gt;
    {
        struct Deleter          // Deleter receives the pointer
        {                       // and calls delete[]
           void operator()(Type* ptr)
           {
              delete[] ptr;
           }
        };
        public:
            shared_array(Type *p)           // other constructors
            :                               // not shown here
                shared_ptr&lt;Type&gt;(p, Deleter())
            {}
            Type &amp;operator[](size_t idx)    // index operators
            {
                return shared_ptr&lt;Type&gt;::get()[idx];
            }
            Type const &amp;operator[](size_t idx) const
            {
                return shared_ptr&lt;Type&gt;::get()[idx];
            }
            Type &amp;operator*() = delete;     // delete pointless members
            Type const &amp;operator*() const = delete;
            Type *operator-&gt;() = delete;
            Type const *operator-&gt;() const = delete;
    };
    int main()
    {
        shared_array&lt;X&gt; sp(new X[3]);
        sp[0] = sp[1];
    }
</pre>
<p>
<a name="l335"></a>
<h2>18.5: Using `make_shared' to combine `shared_ptr' and `new'</h2>
Usually a <code>shared_ptr</code> is initialized at definition time
with a pointer to a newly allocated object. Here is an example:
        <pre>
    std::shared_ptr&lt;string&gt; sptr(new std::string("hello world"))
</pre>
    In such statements <em>two</em> memory allocation calls are used: one for the
allocation of the <code>std::string</code> and one used interally by
<code>std::shared_ptr</code>'s constructor itself.
<p>
The two allocations can be combined into one single allocation (which is
also slightly more efficient than explicitly calling <code>shared_ptr</code>'s
constructor) using the <a name="an2174"></a><code>make_shared</code> template. The function template
<code>std::make_shared</code> has the following prototype:
        <pre>
    template&lt;typename Type, typename ...Args&gt;
    std::shared_ptr&lt;Type&gt; std::make_shared(Args ...args);
</pre>
    Before using <code>make_shared</code> the <a name="an2175"></a><code>&lt;memory&gt;</code> header file must have
been included.
<p>
This function template allocates an object of type <code>Type</code>, passing
<code>args</code> to its constructor (using <em>perfect forwarding</em>, see section
<a href="cplusplus21.html#PERFECT">21.5.2</a>), and returns a <code>shared_ptr</code> initialized with the address of
the newly allocated <code>Type</code> object.
<p>
Here is how the above <code>sptr</code> object can be initialized
using <code>std::make_shared</code>. Notice the use of <code>auto</code> which frees us from
having to specify <code>sptr</code>'s type explicitly:
        <pre>
    auto sptr(std::make_shared&lt;std::string&gt;("hello world"));
</pre>
    After this initialization <code>std::shared_ptr&lt;std::string&gt; sptr</code> has been
defined and initialized. It could be used as follows:
        <pre>
    std::cout &lt;&lt; *sptr &lt;&lt; '\n';
</pre>
<p>
<a name="l336"></a>
<h2>18.6: Classes having pointer data members</h2>
Classes having <a name="an2176"></a> pointer data members require special
attention. In particular at construction time one must be careful to prevent
 <a name="an2177"></a> wild pointers and/or <a name="an2178"></a> memory leaks. Consider
the following class defining two pointer data members:
        <pre>
    class Filter
    {
        istream *d_in;
        ostream *d_out;
        public:
            Filter(char const *in, char const *out);
    };
</pre>
    Assume that <code>Filter</code> objects filter information read from <code>*d_in</code> and
write the filtered information to <code>*d_out</code>.  Using pointers to streams
allows us to have them point at any kind of stream like <code>istreams,
ifstreams, fstreams</code> or <code>istringstreams</code>.  The shown constructor could be
implemented like this:
        <pre>
    Filter::Filter(char const *in, char const *out)
    :
        d_in(new ifstream(in)),
        d_out(new ofstream(out))
    {
        if (!*d_in || !*d_out)
            throw string("Input and/or output stream not available");
    }
</pre>
    Of course, the construction could fail. <code>new</code> could throw an exception;
the stream constructors could throw exceptions; or the streams could not be
opened in which case an exception is thrown from the constructor's body. Using
a function try block helps. Note that if <code>d_in</code>'s initialization throws,
there's nothing to be worried about. The <code>Filter</code> object hasn't been
constructed, its destructor is not be called and processing continues at the
point where the thrown exception is caught. But <code>Filter</code>'s destructor is
also not called when <code>d_out</code>'s initialization or the constructor's <code>if</code>
statement throws: no object, and hence no destructor is called. This may
result in memory leaks, as <code>delete</code> isn't called for <code>d_in</code> and/or
<code>d_out</code>. To prevent this, <code>d_in</code> and <code>d_out</code> must first be initialized
to 0 and only then the initialization can be performed:
        <pre>
    Filter::Filter(char const *in, char const *out)
    try
    :
        d_in(0),
        d_out(0)
    {
        d_in = new ifstream(in);
        d_out = new ofstream(out);

        if (!*d_in || !*d_out)
            throw string("Input and/or output stream not available");
    }
    catch (...)
    {
        delete d_out;
        delete d_in;
    }
</pre>
    This quickly gets complicated, though. If <code>Filter</code> harbors yet another
data member of a class whose constructor needs two streams then that data
cannot be constructed or it must itself be converted into a pointer:
        <pre>
    Filter::Filter(char const *in, char const *out)
    try
    :
        d_in(0),
        d_out(0)
        d_filterImp(*d_in, *d_out)    // won't work
    { ... }

    // instead:

    Filter::Filter(char const *in, char const *out)
    try
    :
        d_in(0),
        d_out(0),
        d_filterImp(0)
    {
        d_in = new ifstream(in);
        d_out = new ofstream(out);
        d_filterImp = new FilterImp(*d_in, *d_out);
        ...
    }
    catch (...)
    {
        delete d_filterImp;
        delete d_out;
        delete d_in;
    }
</pre>
    Although the latter alternative works, it quickly gets hairy. In
situations like these smart pointers should be used to prevent the
hairiness. By defining the stream pointers as (smart pointer) objects they
will, once constructed, properly be destroyed even if the rest of the
constructor's code throws exceptions. Using a <code>FilterImp</code> and two
<code>unique_ptr</code> data members <code>Filter</code>'s setup and its constructor becomes:
        <pre>
    class Filter
    {
        std::unique_ptr&lt;std::ifstream&gt; d_in;
        std::unique_ptr&lt;std::ofstream&gt; d_out;
        FilterImp d_filterImp;
        ...
    };

    Filter::Filter(char const *in, char const *out)
    try
    :
        d_in(new ifstream(in)),
        d_out(new ofstream(out)),
        d_filterImp(*d_in, *d_out)
    {
        if (!*d_in || !*d_out)
            throw string("Input and/or output stream not available");
    }
</pre>
    We're back at the original implementation but this time without having to
worry about wild pointers and memory leaks. If one of the member initializers
throws the destructors of previously constructed data members (which are now
objects) are always called.
<p>
As a <a name="an2179"></a>rule of thumb: when classes need to define pointer data members
they should define those pointer data members as smart pointers if there's any
chance that their constructors throw exceptions.
<p>
<a name="l337"></a>
<h2>18.7: Specifying time (absolute and relative)</h2>
Traditionally, <strong>sleep</strong>(3) or <strong>select</strong>(2) are the tools used to postpone a
program for a specified amount of time. When developing multi threaded
programs situations are frequently encountered where one thread's actions are
temporarily suspended. E.g., a program configuring a network interface may
want to show that it's busy by displaying a sequence of dots, one dot per
second, until the network interface has been configured. The thread displaying
de dots waits for a second before displaying the next dot. Once the network
interface has been configured the the other tread should be notified that it
should stop, requiring facilities to interrupt the waiting process.
<p>
The STL offers dedicated classes which work well in combination with threads,
the topic of the next section, but which can also used in many other
situations. 
<p>
--------------------
 In the <strong>C++</strong> Annotations these classes are covered for as much as
required in combination with multi-threading. The user is referred to the
C++11 standard for additional details about <code>ratio, duration</code>, and
<code>time_point</code>. 
<p>
Before using either <code>duration</code> or <code>time_point</code> the
<a name="an2180"></a><code>&lt;chrono&gt;</code> header file must have been included, where the latter header file
includes the former.
<p>
and a specific point in time is defined using the class template
    <code>time_point</code>.
<p>
Once a <code>ratio</code> type has been defined (e.g.,
<code>typedef ratio&lt;1, 1000&gt; milli</code>) or becomes available (e.g., as
<code>seconds::period</code>, see below), then the value of the template's first
argument (e.g., 1) can be retrieved as <a name="an2181"></a><code>num</code> (e.g.,
<code>seconds::period::num</code>), while the value of the template's second argument
(e.g., 1000) can be retrieved as <a name="an2182"></a><code>den</code> (e.g., <code>seconds::period::den</code>).
<p>
<a name="l338"></a>
<h3>18.7.1: Time units: the class 'ratio'</h3>
    Threads may postpone their actions until a specific point in time or for a
specific amount of time. A time unit is defined using the class template 
<code>std::ratio</code>. 
<p>
Before the class <code>ratio</code> can be used, the <a name="an2183"></a><code>&lt;ratio&gt;</code> header file must have
been included. However, the <code>ratio</code> header file is automatically included
when including the <a name="an2184"></a><code>&lt;chrono&gt;</code> header file.
<p>
The class template <code>ratio</code> expects two integral (for all practical purposes:
positive) template arguments, defining, respectively, the numerator and
denominator of a time unit. By default, the denomincator equals
1, resulting in  the <code>ratio's</code> first argument (the numerator) being
interpreted as the <code>ratio's</code> number of seconds. 
<p>
E.g., <code>ratio&lt;1&gt;</code> defines a time unit of one second; <code>ratio&lt;60&gt;</code> defines a
time unit of 60 seconds, so it defines a unit of a minute; and <code>ratio&lt;1,
1000&gt;</code> defines a unit of 1/1000 second, so it defines a unit of one milli
second.
<p>
A <code>ratio's</code> numerator is directly accessible as its <code>num</code><a name="an2185"></a>
field. A <code>ratio's</code> denominator is directly accessible as its
<code>den</code><a name="an2186"></a> field.  
<p>
A rather large number of predefined <code>ratio</code> types exist. They can be used
instead of the more cumbersome <code>ratio&lt;x&gt;</code> or <code>ratio&lt;x, y&gt;</code> specification:
    <center>
    <table>

    <td colspan=2><hr></td>

    
<tr>
<td> <a name="an2187"></a>yocto</td>  <td> 10<sup>-24</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2188"></a>zepto</td>  <td> 10<sup>-21</sup></td>
 
</tr>

    <td colspan=2><hr></td>

    
<tr>
<td> <a name="an2189"></a>atto</td>  <td> 10<sup>-18</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2190"></a>femto</td> <td> 10<sup>-15</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2191"></a>pico</td>  <td> 10<sup>-12</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2192"></a>nano</td>  <td> 10<sup>-9</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2193"></a>micro</td> <td> 10<sup>-6</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2194"></a>milli</td> <td> 10<sup>-3</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2195"></a>centi</td> <td> 10<sup>-2</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2196"></a>deci</td>  <td> 10<sup>-1</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2197"></a>deca</td>  <td> 10<sup>1</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2198"></a>hecto</td> <td> 10<sup>2</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2199"></a>kilo</td>  <td> 10<sup>3</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2200"></a>mega</td>  <td> 10<sup>6</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2201"></a>giga</td>  <td> 10<sup>9</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2202"></a>tera</td>  <td> 10<sup>12</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2203"></a>peta</td>  <td> 10<sup>15</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2204"></a>exa</td>   <td> 10<sup>18</sup></td>
 
</tr>

    <td colspan=2><hr></td>

    
<tr>
<td> <a name="an2205"></a>zetta</td>   <td> 10<sup>21</sup></td>
 
</tr>

    
<tr>
<td> <a name="an2206"></a>yotta</td>   <td> 10<sup>24</sup></td>
 
</tr>

    <td colspan=2><hr></td>

    
</table>
    </center>
 (<em>note:</em> the definitions of the types <code>yocto, zepto, zetta</code> and <code>yotta</code>
use integral constants exceeding 64 bits, and although these constants are
defined in the C++11 standard, they are not available on 64 bit or smaller
architectures.)
<p>
<a name="l339"></a>
<h3>18.7.2: An amount of time: the class 'duration'</h3>
    The class template <a name="an2207"></a><code>duration</code> is defined in the <code>std::chrono</code> namespace.
Objects of the class <code>duration</code> define a certain amount of time.
<p>
Before using the class <code>std::chrono::duration</code> the <a name="an2208"></a><code>&lt;chrono&gt;</code> header file
must have been included. When including <code>chrono</code> the header file <a name="an2209"></a><code>&lt;ratio&gt;</code>
is also included.
<p>
The class template <code>duration</code> requires two template type arguments: a
numeric type (commonly <a name="an2210"></a><code>int64_t</code>) to contain the duration's value, and a
time-unit, called its <em>Period</em>, usually specified using the class template
<code>ratio</code>.
<p>
Using predefined <code>ratio</code> types amounts of time of various granularities can
be defined. E.g., to define a time interval of 30 minutes you could use
        <pre>
    std::chrono::duration&lt;int64_t, std::deca&gt; halfHour(30)
</pre>
    but even if you're <code>using namespace std</code> and <code>using namespace chrono</code>
this is a rather complex and non-intuitive definition. Fortunately, various
duration types have been predefined:
<p>
<center>
    <table>

    <td colspan=2><hr></td>

    
<tr>
<td> <a name="an2211"></a>nanoseconds</td>    <td> <code>duration&lt;int64_t, nano&gt;</code></td>
 
</tr>

    
<tr>
<td> <a name="an2212"></a>microseconds</td>   <td> <code>duration&lt;int64_t, micro&gt;</code></td>
 
</tr>

    
<tr>
<td> <a name="an2213"></a>milliseconds</td>   <td> <code>duration&lt;int64_t, milli&gt;</code></td>
 
</tr>

    
<tr>
<td> <a name="an2214"></a>seconds</td>        <td> <code>duration&lt;int64_t&gt;</code></td>
 
</tr>

    
<tr>
<td> <a name="an2215"></a>minutes</td>        <td> <code>duration&lt;int64_t, ratio&lt;60&gt;</code><code>&gt;</code></td>
 
</tr>

    
<tr>
<td> <a name="an2216"></a>hours</td>          <td> <code>duration&lt;int64_t, ratio&lt;3600&gt;</code><code>&gt;</code></td>
 
</tr>

    <td colspan=2><hr></td>

    
</table>
    </center>
<p>
Using these types, a duration of 30 minutes can now simply
be defined as <code>std::chrono::minutes halfHour(30)</code>.
<p>
Duration types themselves define the following types:
    <ul>
    <li><a name="an2217"></a><code>std::chrono::duration&lt;Value, Period&gt;::rep</code>:<blockquote>the <code>Value</code> type used by the <code>duration</code> type (e.g., <code>int64_t</code>)</blockquote>
    <li><a name="an2218"></a><code>std::chrono::duration&lt;Value, Period&gt;::period</code>:<blockquote>the <code>Period</code> type used by the <code>duration</code> type (e.g., 
            <code>std::ratio::nano</code>)</blockquote>
    </ul>
<p>
In addition to the copy constructor (and overloaded assignment operator) the
class template <code>duration</code> offers the following constructors:
    <ul>
    <li><code>constexpr duration()</code>:
        the default duration defines a duration of zero time units.
    <li><code>constexpr explicit duration(Value const &amp;value)</code>:
        a specific duration of <code>value</code> time units. Here <code>Value</code> refers to
        the duration's numeric type (e.g., <code>int64_t</code>). So, when defining
        <pre>
    std::chrono::minutes halfHour(30);
</pre>
        the argument 30 is stored inside a <code>int64_t</code>.
    </ul>
<p>
The class template <code>duration</code> offers the following members:
    <ul>
    <li> Arithmetic operators.
       <blockquote>Duration objects may be added, subtracted, multiplied, divided
        and they support the modulo operator (the binary arithmetic and the
        binary arithmetic assignment operators are available).</blockquote>
<p>
<li><a name="an2219"></a><code>constexpr Value count() const</code>:<blockquote>returns the <em>value</em> that is stored inside a <code>duration</code> object. For
        <code>halfHour</code> this would return 30, not 1800, as the time unit itself
        is obtained as the <a name="an2220"></a><code>duration&lt;Value, Unit&gt;::period</code> type.</blockquote>
<p>
<li><a name="an2221"></a><code>static constexpr duration zero()</code>:<blockquote>this is a static member, returning a duration object representing a
        duration of zero time units.</blockquote>
<p>
<li><a name="an2222"></a><code>static constexpr duration min()</code>:<blockquote>this is a static member, returning a duration object 
        representing <code>numeric_limits&lt;Rep&gt;::lowest()</code>.</blockquote>
<p>
<li><a name="an2223"></a><code>static constexpr duration max()</code>:<blockquote>this is a static member, returning a duration object 
        representing <code>numeric_limits&lt;Rep&gt;::max()</code>.</blockquote>
    </ul>
<p>
Different <code>duration</code> types may be combined, unless time precision would be
lost. When the binary arithmetic operators are used the resulting <code>duration</code>
uses the finer of the two granularities. When the binary arithmetic assignment
operator is used the granulatity of the left-hand side operand must at least
be equal to the granularity of the right-hand side operand, or a compilation
error is issued. E.g.,
        <pre>
    std::chrono::minutes halfHour(30);
    std::chrono::seconds half_a_minute(30);

    cout &lt;&lt; (halfHour + half_a_minute).count(); // displays 1830

    //halfHour += half_a_minute;    won't compile: precision is lost

    half_a_minute += halfHour;
    cout &lt;&lt; half_a_minute.count();              // displays 1830
</pre>
<p>
<a name="l340"></a>
<h3>18.7.3: Clocks measuring time</h3>
    The C++11 standard offers several predefined <a name="an2224"></a><em>clock</em> types, measuring time.
All predefined clocks are defined in the <code>std::chrono</code> namespace.  
<p>
Before using the predefined clocks the <a name="an2225"></a><code>&lt;chrono&gt;</code> header file must have been
included. When including <code>chrono</code> the header file <a name="an2226"></a><code>&lt;ratio&gt;</code> is also
included.
<p>
A clock type must be specified when defining points in time using
<code>time_point</code> (covered by the next section). It is also possible to define
your own clock type, which must then satisfy the requirements defined in
clause 20.11.3 of the C++11 standard. Defining your own clock type is not
covered by the <strong>C++</strong> Annotations.
<p>
All predefined clocks provide type definitions and a member <code>now</code>. If
<code>ClockType</code> is a predefined clock type, then
    <ul>
    <li><a name="an2227"></a><code>std::chrono::ClockType::duration</code>:<blockquote>the <code>duration</code> type (e.g., <code>std::chrono::nanoseconds</code> 
         used by <code>ClockType</code>)</blockquote>
    <li><a name="an2228"></a><code>std::chrono::ClockType::period</code>:<blockquote>the time period used by <code>ClockType</code> (e.g.,
         <code>std::ratio::nano</code>)</blockquote> 
    <li><a name="an2229"></a><code>std::chrono::ClockType::rep</code>:<blockquote>defining the value type used by <code>ClockType</code> to store duration values
         (e.g., <code>int64_t</code>)</blockquote>
    <li><a name="an2230"></a><code>std::chrono::ClockType::time_point</code>:<blockquote>time points used by <code>ClockType</code> 
         (e.g., <code>std::chrono::time_point&lt;system_clock, duration&gt;</code>)</blockquote>
    </ul>
<p>
In addition to these types predefined clocks offer a member
    <ul>
    <li><a name="an2231"></a><code>static std::chrono::time_point 
                      std::chrono::ClockType::now()</code>:<blockquote>returns the <code>time_point</code> representing the current time</blockquote>
    </ul>
<p>
The following predefined clock types are available:
    <ul>
    <li><a name="an2232"></a><code>std::chrono::system_clock</code>:<blockquote>the `wall clock' time, using the system's real time clock. 
        In addition to <code>now</code> the class <code>system_clock</code>
        offers these two static members:
        <ul>
        <li><a name="an2233"></a><code>static time_t std::chrono::system_clock::to_time_t</code>
                <blockquote><code>(std::chrono::time_point const &amp;
                timePoint)</code></blockquote>
            <blockquote>a <code>time_t</code> value representing the same point in time as
                <code>timePoint</code>;</blockquote>
        <li><a name="an2234"></a><code>static std::chrono::time_point
                std::chrono::system_clock::from_time_t</code>
                <blockquote><code>(time_t seconds)</code></blockquote>
            <blockquote>a <code>time_point</code> value representing the same point in time
                as <code>time_t</code>.</blockquote>
        </ul>
        </blockquote>
    <li><a name="an2235"></a><code>std::chrono::steady_clock</code>:<blockquote>a clock whose time increases in parallel with the increase of real
        time.</blockquote> 
    <li><a name="an2236"></a><code>std::chrono::high_resolution_clock</code>:<blockquote>the computer's fastest clock (i.e., the clock having the shortest
        timer-tick period). In practice this is the clock used to implement
        the <code>system_clock</code>.</blockquote>  
    </ul>
<p>
As an example: to access the current time you could use:
        <pre>
    auto point = std::chrono::system_clock::now();
</pre>
<p>
<a name="l341"></a>
<h3>18.7.4: Points in time: the class 'time_point'</h3>
    The class <a name="an2237"></a><code>time_point</code> is defined in the <code>std::chrono</code> namespace.<br>
Objects of the class <code>std::chrono::time_point</code> define a moment in time.
<p>
Before using the class <code>std::chrono::time_point</code> the <a name="an2238"></a><code>&lt;chrono&gt;</code> header
file must have been included. When including <code>chrono</code> the header file
<a name="an2239"></a><code>&lt;ratio&gt;</code> is also included.
<p>
The class  <code>time_point</code> is a class template, 
requires two template type arguments: a <code>Clock</code> type and a <code>Duration</code>
type. 
<p>
The <code>Clock</code> type usually is one of the predefined clock types, e.g.,
<code>chrono::system_clock</code>. The <code>Duration</code> type may be omitted, in which case
the <code>Clock's duration</code> type is used. An explicit <code>duration</code> type may also
be provided. 
<p>
In the previous section <code>auto</code> was used to specify the type of the return
value of <code>system_clock::now</code>. The explicit definition looks like this:
    <pre>
    std::chrono::time_point&lt;std::chrono::system_clock&gt; now = 
        std::chrono::system_clock::now();
</pre>
<p>
The class <code>std::chrono::time_point</code> offers three constructors:
    <ul>
    <li><code>time_point()</code>:<blockquote>the default constructor represents the beginning of the clock's
        <a name="an2240"></a><em>epoch</em> (E.g., Jan, 1, 1970, 00:00h);</blockquote>
    <li><code>time_point(time_point&lt;Clock, Duration&gt; const &amp;timeStep)</code>:<blockquote>initializes a <code>time_point</code> object representing a point in time
        <code>timeStep Duration</code> units byond the clock's epoch;</blockquote>
    <li><code>time_point(time_point&lt;Clock, Duration2&gt; const &amp;timeStep)</code>:<blockquote>this constructor is defined as a member template, using the template
        header <code>template &lt;typename Duration2&gt;</code>. The type <code>Duration2</code> is a
        <code>std::chrono::duration</code> (or comparable) type, using a possibly
        larger period for its unit than <code>time_point's Duration</code>
        type. It initializes a <code>time_point</code> object representing a point in
        time <code>timeStep Duration2</code> units byond the clock's epoch.</blockquote>
    </ul>
<p>
The class <code>std::chrono::time_point</code> offers these operators and members:
    <ul>
    <li><code>std::chrono::time_point &amp;operator+=(Duration const &amp;duration)</code>:<blockquote>this operator is also available as binary arithmetic 
        operator,
        expecting a <code>std::chrono::time_point const &amp;</code> and a <code>Duration
        const &amp;</code> argument (in any order).  The amount of time represented by
        <code>duration</code> is added to the current <code>time_point</code> value. Example:
       <pre>
    std::chrono::system_clock::now() + seconds(5);
</pre>
        </blockquote>
<p>
<li><code>std::chrono::time_point &amp;operator-=(Duration const &amp;duration)</code>:<blockquote>this operator is also available as binary arithmetic 
        operator,
        expecting a <code>std::chrono::time_point const &amp;</code> and a <code>Duration
        const &amp;</code> argument (in any order).  The amount of time represented by
        <code>duration</code> is subtracted from the current <code>time_point</code>
        value. Example:
       <pre>
    auto point = std::chrono::system_clock::now();
    point -= seconds(5);
</pre>
        </blockquote>
<p>
<li><a name="an2241"></a><code>constexpr Duration time_since_epoch() const</code>:<blockquote>returns the object's <code>Duration</code> since the epoch.</blockquote>
<p>
<li><a name="an2242"></a><code>static constexpr time_point min()</code>:<blockquote>a static member returning the value returned by the time point's
        <code>duration::min</code> value.</blockquote>
<p>
<li><a name="an2243"></a><code>static constexpr time_point max()</code>:<blockquote>a static member returning the value returned by the time point's
        <code>duration::max</code> value.</blockquote>
    </ul>
<p>
All predefined clocks use nanoseconds as their time unit. To obtain the
time expressed in a larger time unit, divide the value returned by the 
<code>time_point's count</code> value by larger time unit 
converted to nanoseconds. E.g., the number of hours passed since the beginning
of the epoch is:
        <pre>
    using namespace std;
    using namespace chrono;     // for brevity

    cout &lt;&lt; system_clock::now().time_since_epoch().count() /
            nanoseconds(hours(1)).count() &lt;&lt; " hours since the epoch\n";
</pre>
<p>
To convert the time to a textual representation standard <strong>C</strong> functions can
be used. These functions usually expect arguments in seconds, as returned by
the <strong>time</strong>(2), function. Given that a <code>time_point</code> is available, the
system clock's static member <code>to_time_t</code> can be used to convert a
<code>time_point</code> value to a <code>time_t</code> value, after which the time in seconds
can, e.g., be converted to a textual representation. E.g.,
        <pre>
    using namespace std;
    using namespace chrono;     // for brevity

    time_t tm = system_clock::to_time_t(system_clock::now() + hours(1));
    cout &lt;&lt; asctime(localtime(&amp;tm));
</pre>
<p>
Here are some more examples showing how <code>time_point</code> objects can be used:
    <pre>
    #include &lt;iostream&gt;
    #include &lt;chrono&gt;

    using namespace std;
    using namespace chrono;

    int main()
    {
            // the current time (or use `auto')
        time_point&lt;system_clock&gt; now(system_clock::now());

            // its value in seconds:
        cout &lt;&lt; system_clock::to_time_t(now) &lt;&lt; '\n';

            // now + two hours:
        cout &lt;&lt; system_clock::to_time_t(now + hours(2)) &lt;&lt; '\n';

            // define a time_point 1 hour after the epoch:
        time_point&lt;system_clock&gt; oneHrLater(hours(1));

            // show the epoch and the time in seconds of oneHrLater:
        cout &lt;&lt; system_clock::to_time_t(time_point&lt;system_clock&gt;()) &lt;&lt; ' ' &lt;&lt;
                system_clock::to_time_t(oneHrLater) &lt;&lt; '\n';
    }
</pre>
<p>
<a name="l342"></a>
<h2>18.8: Multi Threading</h2>
The C++11 standard adds <a name="an2244"></a>multi threading to <strong>C++</strong> through the <strong>C++</strong>
standard library.
<p>
<a name="PTHREADS"></a> The <strong>C++</strong> Annotations do not cover the concepts behind multi
threading. It is assumed that the reader has a basic knowledge of these
concepts. Multi threading is a topic by itself and many good reference sources
exist (cf.  <a name="an2245"></a>Nichols, B, <em>et al.</em>'s
        <a href="http://oreilly.com/catalog/">Pthreads Programming</a>, O'Reilly
        <a name="an2246"></a><a name="an2247"></a>
    for some good introductions to multi-threading).
<p>
Multi threading facilities are offered by the class <code>std::thread</code>. 
<p>
Thread synchronization is realized using objects of the class <code>std::mutex</code>
and <em>condition variables</em> are implemented by the class
<code>std::condition_variable</code>.
<p>
Members of these classes may throw <code>system_error</code> objects (cf. section
<a href="cplusplus10.html#SYSTEMERROR">10.9</a>) when encountering a low-level error condition.
<p>
In order to <a name="an2248"></a> use multi threading in <strong>C++</strong>
programs the Gnu <code>g++</code> compiler requires the use of the <code>-pthread</code>
        <a name="an2249"></a><a name="an2250"></a>
 flag. E.g., to compile a multi-threaded program defined in a source file
<code>multi.cc</code> the compiler must be called as follows:
        <pre>
    g++ --std=c++11 -pthread -Wall multi.cc
</pre>
<p>
<a name="l343"></a>
<h3>18.8.1: The namespace `std::this_thread'</h3>
    The <a name="an2251"></a><code>namespace this_thread</code><a name="an2252"></a> is defined within the <code>std</code>
namespace, and contains functions that uniquely identify the current thread of
execution. 
<p>
It offers the following members:
    <ul>
    <li><a name="an2253"></a><code>thread::id get_id() noexcept</code>:<blockquote>returns an object of type <code>thread::id</code> that uniquely identifies the
        currently active thread of execution. For an active thread the
        returned <code>id</code>s is unique in that it 1:1 maps to the currently active
        thread, and is not returned for any other thread. A default <code>id</code> is
        returned when <code>get_id</code> is called for a thread that is currently not
        running.</blockquote>
    <li><a name="an2254"></a><code>void yield() noexcept</code>:<blockquote>
       the implementation may call <code>yield</code> to
        reschedule. Cf. <code>thread::yield</code> in section <a href="cplusplus18.html#THREAD">18.8.2</a>.</blockquote>
    <li><a name="an2255"></a><code>void sleep_for(chrono::duration&lt;Rep, Period&gt; const &amp;relTime)
            noexcept</code>:<blockquote>this function is defined as a function template, defining the
        template header <code>template &lt;typename Rep, typename Period&gt;</code>. The template's
        types are derived from the actual <code>relTime</code> argument that is passed
        to the function, and should not explicitly be specified. This function
        could be called as, e.g., 
   <pre>
sleep_for(seconds(5));
</pre>
       Calling this function blocks the thread calling this function during the
        specified time interval, starting at the point in time the function is
        called.</blockquote>
    <li><a name="an2256"></a><code>void sleep_until(chrono::time_point&lt;Clock, Duration&gt; const &amp;absTime)
            noexcept</code>:<blockquote>this function is also defined as a function template, defining the
        template header <code>template &lt;typename Clock, typename Duration&gt;</code>. The
        <code>Clock</code> and <code>Duration</code> types are derived from the actual
        <code>absTime</code> argument that is passed to the function, and should not
        explicitly be specified. This function could be called as, e.g.,
   <pre>
sleep_until(system_clock::now() + seconds(5));
</pre>
       Calling this function blocks the thread until the specified absolute
        point in time.</blockquote>
    </ul>
<p>
<a name="THREAD"></a><a name="l344"></a>
<h3>18.8.2: The class `std::thread'</h3>
    In <strong>C++</strong> multi threading can be realized through the use of objects of the
class <a name="an2257"></a><code>std::thread</code>. Each object of this class handles a separate
<em>thread of execution</em>.
<p>
Before using <code>Thread</code> objects the <a name="an2258"></a><code>&lt;thread&gt;</code> header file must have been
included.
<p>
Threads can be <em>joined</em>, i.e., wait until another thread has finished, and
the <em>states</em> of threads may be queried and controlled by a multi-threaded
program.
<p>
Each <code>thread</code> object represents one unique thread of execution, but its
unique thread may be transferred to another <code>thread</code> object. In this
situation there remains but a single <code>thread</code> object that represents the
running thread.
<p>
If a threads of execution loses its association with a <code>thread</code> object that
thread is said to be <a name="an2259"></a> <em>detached</em>. Conversely, <code>thread</code>
objects by themselves are not necessarily associated with a running thread of
execution: following the default construction, a move operation in which a
<code>thread</code> object acts as  the source <code>thread</code> or after detaching or joining
threads the <code>thread</code> object may still exist, albeit in a state where it is
not or no longer associated with a running thread.
<p>
The class <code>thread</code> offers the following constructors:
    <ul>
    <li><code>thread() noexcept</code>:<blockquote>the default constructor creates a <code>thread</code> object that is not (yet)
        associated with a running thread of execution;</blockquote>
    <li><code>explicit thread(Fun &amp;&amp;fun, Args &amp;&amp;...args)</code>:<blockquote>this constructor is defined as a <em>member template</em> (cf. section
        <a href="cplusplus21.html#MEMTEMP">21.1.3</a>), using the template header <code>template &lt;typename Fun,
        typename ...Args&gt;</code>. Its first argument is a function that implements
        the thread's actions. The notation <code>Args &amp;&amp;...args</code> indicates that
        any number of additional arguments may follow <code>fun</code>. These arguments
        are then passed with their proper types and values to <code>fun</code>. The
        argument passed to <code>fun</code> may also be a function object, whose
        function call operator then receives the <code>...args</code> arguments.
<p>
Function (or function object) and arguments must be 
       <a name="an2260"></a><em>move constructible</em> (i.e., after assignment or initialization the
        target object is equivalent to the original source, while following
        the assignment or construction the source's state is not
        specified). After (move-)constructing copies of <code>fun</code> and
        <code>...args</code> the <code>thread</code> object has been constructed. Following the
        <code>thread</code> object construction (but not as part of the construction),
        a separately running thread of execution, associated with the just
        constructed <code>thread</code> object, is started.
<p>
If the requested thread cannot be created a <code>system_error</code> is
        thrown.</blockquote>
    <li><code>thread(thread &amp;&amp;tmp) noexcept</code>:<blockquote>the move constructor uses <code>tmp</code> to construct the target <code>thread</code>
        object and puts <code>tmp</code> in the <code>thread</code>'s default state.</blockquote>
    </ul>
<p>
When a <code>thread</code> object is destroyed while its thread of execution is
still active, <code>terminate</code> is called, forcing the program's end. So, before
calling a <code>thread</code> object's destructor its thread of execution must have
been terminated. This is accomplished by ending the function which was passed
to the <code>thread</code> object's constructor.
<p>
In the following example a <code>thread</code> object is created, inserting the
text <code>hello world</code> three times into <code>cout</code>:
        <pre>
    #include &lt;thread&gt;
    #include &lt;iostream&gt;
    #include &lt;unistd.h&gt;

    using namespace std;

    // do not forget to use -pthread with g++

    void fun(size_t count, char const *txt)
    {

        for (; count--; )
            cout &lt;&lt; txt &lt;&lt; endl;
    }
    int main()
    {                   // runs the thread following
                        // the object construction
        thread display(fun, 3, "hello world");

        display.join(); // see the text
    }
</pre>
<p>
The members of the class <code>thread</code> are:
    <ul>
    <li><a name="an2261"></a><code>void detach()</code>:<blockquote>requires <code>joinable</code> to return <code>true</code>.  The thread for which
        <code>detach</code> is called continues its execution. The (e.g., parent)
        thread calling <code>detach</code> continues its execution immediately beyond
        the <code>detach</code>-call.  After calling <code>object.detach()</code>, `<code>object</code>'
        no longer represents the, possibly still continuing but now detached,
        thread of execution. It is the detached thread's implementation's
        responsibility to release its resources when its execution ends. 
<p>
Since <code>detach</code> disconnects a thread from the running program, e.g.,
        <code>main</code> no longer can wait for the thread's completion.  As a program
        ends when <code>main</code> ends, its still running threads also stop, and
        program may not properly complete all its threads, as demonstrated by
        the following program: 
            <pre>
    #include &lt;thread&gt;
    #include &lt;iostream&gt;
    #include &lt;unistd.h&gt;

    using namespace std;

    // do not forget to use -lpthread with g++

    void fun(size_t count, char const *txt)
    {

        for (; count--; )
            cout &lt;&lt; count &lt;&lt; ": " &lt;&lt; txt &lt;&lt; endl;
    }

    int main()
    {                   // runs the threads following
                        // the object construction
        thread display(fun, 3, "hello world");
        display.detach();

        thread second(fun, 3, "a second thread");
        second.detach();

        cout &lt;&lt; "leaving" &lt;&lt; endl;
    }
</pre>
       When this program is run, only part of the potentially generated output
        is inserted into <code>cout</code>, like: 
   <pre>
leaving22: hello world
</pre>
        </blockquote>
    <li><a name="an2262"></a><code>id get_id() const noexcept</code>:<blockquote>If the current object does not represent a a running thread a default
        <code>id</code> object is returned. Otherwise, <code>this_thread::get_id()</code> is
        returned for the running thread that is associated with the object for
        which <code>get_id</code> is called is returned.</blockquote>
    <li><a name="an2263"></a><code>void join()</code>:<blockquote>requires <code>joinable</code> to return <code>true</code>.  Blocks the thread calling
        <code>join</code> until the thread for which <code>join</code> is called has
        completed. Following its completion the object whose <code>join</code> member
        was called no longer represents a running thread, and its <code>get_id</code>
        member will return the default <code>id</code>.<br>
       An example of its use is provided by the above example. In that example
        <code>join</code> is called to prevent <code>display</code> from being destroyed at the
        end of <code>main</code>. Without calling <code>join</code> <code>display</code>'s thread would
        still have been running by the time <code>main</code>'s execution would have
        reached its end. At that point <code>display</code>'s destructor would have
        been called. However, when the destructor of a <em>joinable thread</em> is
        called, <code>terminate</code> is called, forcing the program's abort.</blockquote>
    <li><a name="an2264"></a><code>bool joinable() const noexcept</code>:<blockquote>returns <code>object.get_id() != id()</code>, where <code>object</code> is the
        <code>thread</code> object for which <code>joinable</code> was called.</blockquote>
    <li><a name="an2265"></a><code>void swap(thread &amp;other) noexcept</code>:<blockquote>The states of the <code>thread</code> object for which <code>swap</code> was called and
        <code>other</code> are swapped. Note that threads may be swapped as well, even
        when their threads of execution are currently active.</blockquote>
    </ul>
<p>
The class <code>thread</code> supports the move assignment operator:
    <ul>
    <li><code>thread &amp;operator=(thread &amp;&amp;tmp) noexcept</code>:
        If the operator's left-hand side operand (lhs) is a joinable thread,
then <code>terminate</code> is called. Otherwise, <code>other</code>'s state is assigned to the
operator's lhs and sets <code>other</code> to the thread's default constructed state.
    </ul>
<p>
Since the <code>tread(Fun &amp;&amp;fun, Args &amp;&amp;...args)</code> constructor not only accepts
functions but also function objects as its argument, a <a name="an2266"></a><em>local context</em> may
be passed to the function object's constructor. Here is an example of a thread
to which a function object is passed which is provided with a local context:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;thread&gt;
    #include &lt;array&gt;

    using namespace std;

    class Functor
    {
        array&lt;int, 30&gt; &amp;d_data;
        int d_value;

        public:
            Functor(array&lt;int, 30&gt; &amp;data, int value)
            :
                d_data(data),
                d_value(value)
            {}
            void operator()(ostream *out)
            {
                for (auto &amp;value: d_data)
                {
                    value = d_value++;
                    *out &lt;&lt; value &lt;&lt; ' ';
                }
                *out &lt;&lt; '\n';
            }
    };

    int main()
    {
        array&lt;int, 30&gt; data;
        Functor functor(data, 5);
        thread funThread(functor, &amp;cout);
        funThread.join();
    };
</pre>
    Note the argument <code>&amp;cout</code> that is passed to <code>funThread</code> and the
definition <code>ostream *out</code> parameter of the <code>funThread</code>'s function call
operator. Here <code>cout</code> cannot be used (in combination with an <code>ostream &amp;out</code>
parameter), since the latter parameter is not move-constructible, whereas a
pointer <em>is</em>.
<p>
<a name="l345"></a>
<h3>18.8.3: Synchronization (mutexes)</h3>
        The C++11 standard offers a series of <a name="an2267"></a>mutex classes to protect shared
data.  
<p>
Before using mutexes the <a name="an2268"></a><code>&lt;mutex&gt;</code> header file must have been included.
<p>
Mutexes should be used to prevent data corruption when multiple threads need
access to common data. For (a very simple) example: the following could happen
when two threads access a common int variable, unless mutexes are used (a
<a name="an2269"></a><em>context switch</em> occurs when the operating system switches between
threads. With a mult-processor system the threads can really be executed in
parallel. To keep the example simple, assume multi threading is used on a
single-core computer, switching between multi-threads):
        <pre>
Time step:    Thread1:      var        Thread2:        description
---------------------------------------------------------------------------
    0                        5
    1           starts                                  T1 active
    2           writes var                              T1 commences writing
    3           stopped                                 Context switch
    4                                   starts          T2 active
    5                                   writes var      T2 commences writing
    6                       10          assigns 10      T2 writes 10
    7                                   stopped         Context switch
    8           assigns 12                              T1 writes 12
    9                       12
----------------------------------------------------------------------------
</pre>
    The above is just a very simple illustration of what may go wrong when
multiple threads access the same data without using mutexes. 
<p>
Thread 2 proceeds on the assumption that <code>var</code> equals 10. However, after
step 9 <code>var</code> holds the value 12. Mutexes are used to prevent these kinds of
problems by offering a guarantee that thata are only accessed by the thread
holding a mutex for the those data.
<p>
Exclusive data access completely depends on cooperation between the
threads. If thread 1 uses mutexes, but thread 2 doesn't, then thread 2 may
access the common data any which way it wants to. Of course that's bad
practice, and mutexes allow us to write program not behaving badly in this
sense.
<p>
It is stressed that although <em>using</em> mutexes is the programmer's
responsibility, their <em>implementation</em> isn't. A user-program is unable to
accomplish <em>atomic locking</em> mutexes offer. The bottom line is that if we try
to implement a mutex-like facility in our programs then each statement is
compiled into several machine instructions and in between each of these
instructions the operating system may do a context switch, rendering the
instructions non-atomic.
<p>
Mutexes offer the necessary atomic calls: when requesting a mutex-lock the
thread is suspended (i.e., the mutex statement does not return) until the lock
has been obtained by the thread.
<p>
More information about mutexes can be found in the <a href="cplusplus18.html#PTHREADS">mentioned O'Reilly
book</a> and in general in the extensive literature on this topic. It
is not a topic that is discussed further in the <strong>C++</strong> Annotations. The available
facilities for using mutexes, however, <em>are</em> covered in this section.
<p>
Apart from the class <code>std::mutex</code> the class <a name="an2270"></a>
<code>std::recursive_mutex</code> is offered.  When a <code>recursive_mutex</code> is called
multiple times by the same thread it increases its lock-count. Before other
threads may access the protected data the recursive mutex must be unlocked
again that number of times. Moreover, the classes 
        <a name="an2271"></a><code>std::timed_mutex</code> 
    and 
        <a name="an2272"></a><code>std::recursive_timed_mutex</code> 
    are available. Their locks expire when released, but also after a certain
amount of time.
<p>
All mutex classes offer the following constructors and members:
    <ul>
    <li> A default <code>constexpr</code> constructor;
    <li> A destructor
    <li><a name="an2273"></a><code>void lock()</code>:<blockquote>the calling thread is blocked until it has obtained ownership of the
        mutex. Unless <code>lock</code> is called for a recursive mutex a
        <code>system_error</code> is thrown if, e.g., the thread already owns the
        lock. Recursive mutexes increment their interal <a name="an2274"></a><em>lock count</em>;</blockquote>
    <li><a name="an2275"></a><code>bool try_lock() noexcept</code>:<blockquote>the calling thread tries to obtain ownership of the mutex without
        blocking. If ownership is obtained, <code>true</code> is returned, otherwise
        <code>false</code>. If the lock was already obtained by the calling thread,
        <code>true</code> is also returned, and with a recursive mutex its interal
        <a name="an2276"></a><em>lock count</em> is also incremented;</blockquote>
    <li><a name="an2277"></a><code>void unlock() noexcept</code>:<blockquote>the calling thread releases ownership of the mutex.  A
        <code>system_error</code> is thrown if, e.g., the thread does not own the
        lock. Recursive mutexes decrement their interal lock count, releasing
        ownership of the mutex once the lock count has decayed to zero;</blockquote>
    </ul>
Note: mutex classes do not offer copy constructors and overloaded assignment
operators.
<p>
In addition to the abovementioned members, timed mutex classes
(<code>timed_mutex,</code><code>recursive_timed_mutex</code>) also offer:
    <ul>
    <li><a name="an2278"></a><code>bool try_lock_for(chrono::duration&lt;Rep, Period&gt; const 
            &amp;relTime) noexcept</code>:<blockquote>this function is defined as a function template, defining the template
        header <code>template &lt;typename Rep, typename Period&gt;</code>. The template's
        types are derived from the actual <code>relTime</code> argument that is passed
        to the function, and should not explicitly be specified. This function
        could be called for a <code>timed_mutex_lock tml</code> as, e.g.,
       <pre>
tml.try_lock_for(seconds(5));
</pre>
       If the ownership is obtained within the specified time interval
        <code>true</code> is returned, otherwise <code>false</code>. If the lock was already
        obtained by the calling thread, <code>true</code> is also returned, and with a
        recursive timed mutex its interal <a name="an2279"></a><em>lock count</em> is also
        incremented;</blockquote>
<p>
<li><a name="an2280"></a><code>bool try_lock_until(chrono::time_point&lt;Clock,
            Duration&gt; const &amp;absTime) noexcept</code>:<blockquote>this function is also defined as a function template, defining the
        template header <code>template &lt;typename Clock, typename Duration&gt;</code>. The
        <code>Clock</code> and <code>Duration</code> types are derived from the actual
        <code>absTime</code> argument that is passed to the function, and should not
        explicitly be specified. This function could be called for a
        <code>timed_mutex_lock tml</code> as, e.g.,
   <pre>
tml.try_lock_until(system_clock::now() + seconds(5));
</pre>
       If the ownership is obtained before the specified point in time
        <code>true</code> is returned, otherwise <code>false</code>. If the lock was already
        obtained by the calling thread, <code>true</code> is also returned, and with a
        recursive timed mutex its interal <a name="an2281"></a><em>lock count</em> is also
        incremented;</blockquote>
    </ul>
<p>
<a name="LOCKS"></a><a name="l346"></a>
<h3>18.8.4: Locks and lock handling</h3>
    Often locks are released at the end of some action block. To simplify locking
additional template classes
        <a name="an2282"></a><code>std::unique_lock</code> 
    and 
        <a name="an2283"></a><code>std::lock_guard</code> 
    are provided. At construction time the <code>mutex</code> type to be used must be
specified. As their constructors (usually) lock the data and their destructors
unlock the data they can be defined as local variables, unlocking their data
once their scopes end.
<p>
Locks by default try to acquire the ownership of the <code>mutex</code> type that's
passed to them at construction time. However, that may not always be
convenient. Therefore additional constructors are defined offering additional
modes of operation. These requested modes are specified by passing 
    a <a name="an2284"></a><em>tag type</em> to those constructors that define what
should be done with the lockable object during the lock's construction. The
tag types (and tags) are:
    <ul>
    <li><a name="an2285"></a><code>struct std::defer_lock_t</code>:<blockquote>the lock is not trying to acquire ownership of the mutex. The
        ownership may be requested later during the lock's lifetime. A
        predefined <a name="an2286"></a><code>defer_lock</code> object which may be passed as tag is also
        available;</blockquote>
    <li><a name="an2287"></a><code>struct std::try_to_lock_t</code>:<blockquote>the lock is trying to acquire ownership of the mutex, but won't block
        if this fails. A predefined <a name="an2288"></a><code>try_to_lock</code> object which may be passed
        as tag is also available;</blockquote>
    <li><a name="an2289"></a><code>struct std::adopt_lock_t</code>:<blockquote>the lock won't try to acquire ownership of the lock, but instead
        assumes that the calling thread has already obtained ownership. The
        lock will be released (or the lock-count will be reduced) when the
        lock is destroyed. A predefined <a name="an2290"></a><code>adopt_lock</code> which may be passed as
        tag is also available.</blockquote>
    </ul> 
<p>
Lock types do not define copy constructors or overloaded assignment
operators, nor do they define any other member function. Basically, they only
allow constructions. Their destructors release the ownertship of their mutex
(or, when recursive mutex was passed to them) reduce the mutex's use count.
<p>
A <a name="an2291"></a><code>lock_guard</code> may be constructed by passing it a <code>mutex</code> type and an
optional <code>adopt_lock_t</code> object. 
<p>
Here is a simple example showing the use of a <code>lock_guard</code>. Once
<code>safeProcess</code> ends <code>guard</code> is destroyed, thereby releasing the lock on
<code>data</code>:
        <pre>
    std::mutex dataMutex;
    Data data;

    void safeProcess()
    {
        std::lock_guard&lt;std::mutex&gt; guard(dataMutex);
        process(data);
    }
</pre>
<p>
The class template <a name="an2292"></a><code>unique_lock</code> is much more elaborate than the basic
<code>lock_guard</code> class template.  It does not offer a copy constructor or
overloaded assignment operator, but it <em>does</em> offer a move constructor and
move assignment operator.
<p>
Here are its constructors and members (<code>Mutex</code> refers to the mutex type
that was specified for the <code>unique_lock</code> at construction time). E.g.,
<code>unique_lock&lt;timed_mutex&gt;</code> defines <code>Mutex</code> as a <code>timed_mutex</code> below.
<p>
Here are <code>unique_lock's</code> constructors:
    <ul>
    <li><code>unique_lock() noexcept</code>:<blockquote>the default constructor is not associated with a <code>mutex</code> type. It
        must be assigned a <code>mutex</code> (e.g., using move-assignment) before it
        can do anything useful;<br></blockquote>
    <li><code>explicit unique_lock(Mutex&amp; mutex)</code>:<blockquote>initializes a <code>unique_lock</code> with an existing <code>Mutex</code> object,
        resulting in the lock object obtaining ownership of the <code>Mutex</code>;</blockquote>
    <li><code>unique_lock(Mutex&amp; mutex, defer_lock_t) noexcept</code>:<blockquote>initializes a <code>unique_lock</code> with an existing <code>Mutex</code> object,
        but will not try to obtain ownership of the <code>Mutex</code>;</blockquote>
    <li><code>unique_lock(Mutex&amp; mutex, try_to_lock_t) noexcept</code>:<blockquote>initializes a <code>unique_lock</code> with an existing <code>Mutex</code> object,
        and will try to obtain ownership of the <code>Mutex</code>, but won't block if
        it does not succeed;</blockquote>
    <li><code>unique_lock(Mutex&amp; mutex, adopt_lock_t) noexcept</code>:<blockquote>initializes a <code>unique_lock</code> with an existing <code>Mutex</code> object,
        assuming that the current thread has already obtained ownership of the
        <code>Mutex</code>;</blockquote>
    <li><code>unique_lock(Mutex&amp; mutex, chrono::duration&lt;Rep, Period&gt; const
        &amp;relTime) noexcept</code>:<blockquote>this constructor is defined as a member template, using the template
        header <code>template &lt;typename Rep, typename Period&gt;</code>. The template's types
        are derived from the actual <code>relTime</code> argument that is passed to
        the constructor, and should not explicitly be specified.  The
        constructor will try to obtain ownership of the <code>Mutex</code> object by
        calling <code>mutex.try_lock_for(relTime)</code>. If <code>Mutex mutex</code> is
        available, this constructor could be called like this:
       <pre>
unique_lock&lt;Mutex&gt; ulock(mutex, seconds(5));
</pre>
</blockquote>
    <li><code>unique_lock(Mutex&amp; mutex, chrono::time_point&lt;Clock, Duration&gt; const
        &amp;absTime) noexcept</code>:<blockquote>this constructor is also defined as a member template, using the
        template header <code>template &lt;typename Clock, typename Duration&gt;</code>.  The
        <code>Clock</code> and <code>Duration</code> types are derived from the actual
        <code>absTime</code> argument that is passed to the constructor, and should
        not explicitly be specified. The constructor will try to obtain
        ownership of the <code>Mutex</code> object by calling
        <code>mutex.try_lock_until(absTime)</code>. If <code>Mutex mutex</code> is available,
        this constructor could be called like this:
       <pre>
unique_lock&lt;Mutex&gt; ulock(mutex, system_clock::now() + seconds(5));
</pre>
</blockquote>
    </ul>
<p>
Overloaded operators:
    <ul>
    <li><code>explicit operator bool() const noexcept</code>:<blockquote>returns <code>true</code> if the <code>unique_lock</code> owns the mutex, otherwise
        <code>false</code>; </blockquote>
    <li><code>unique_lock&amp; operator=(unique_lock &amp;&amp;tmp) noexcept</code>:<blockquote>with the move-assignment operator, if the left-hand operand owns a
        lock, it will call its mutex's <code>unlock</code> member, whereafter <code>tmp</code>'s
        state is transferred to the left-hand operand</blockquote>
    </ul>
<p>
Ordinary members:
    <ul>
    <li><a name="an2293"></a><code>void lock()</code>:<blockquote>blocks the current thread until ownership of the mutex that is managed
        by the <code>unique_lock</code> is obtained. If no mutex is currently managed,
        then a <code>system_error</code> exception is thrown.</blockquote>
    <li><a name="an2294"></a><code>bool owns_lock() const noexcept</code>:<blockquote>returns <code>true</code> if the <code>unique_lock</code> owns the mutex, otherwise
        <code>false</code>; </blockquote>
    <li><a name="an2295"></a><code>Mutex *release() noexcept</code>:<blockquote>returns a pointer to the mutex object previously stored inside the
        <code>unique_lock</code> object, setting its own <code>Mutex *</code> data member to 0;</blockquote>
    <li><a name="an2296"></a><code>void swap(unique_lock&amp; other) noexcept</code>:<blockquote>swaps the states of the current <code>unique_lock</code> and <code>other</code>;</blockquote>
    <li><a name="an2297"></a><code>bool try_lock()</code>:<blockquote>tries to obtain ownership of the mutex that is managed by the
        <code>unique_lock</code>, returning <code>true</code> if this succeeds, and <code>false</code>
        otherwise. If no mutex is currently managed, then a <code>system_error</code>
        exception is thrown.</blockquote>
    <li><a name="an2298"></a><code>bool try_lock_for(chrono::duration&lt;Rep, Period&gt; const
        &amp;relTime)</code>:<blockquote>this member is defined as a member template, using the template header
        <code>template &lt;typename Rep, typename Period&gt;</code>. The template's types are
        derived from the actual <code>relTime</code> argument that is passed to this
        member, and should not explicitly be specified.  This member function
        will try to obtain ownership of the <code>Mutex</code> object managed by the
        <code>unique_lock</code> object by calling the mutex's
        <code>try_lock_for(relTime)</code> member.</blockquote>
    <li><a name="an2299"></a><code>bool try_lock_until(chrono::time_point&lt;Clock,
        Duration&gt; const &amp;absTime)</code>:<blockquote>this member is also defined as a member template, using the template
        header <code>template &lt;typename Clock, typename Duration&gt;</code>.  The
        <code>Clock</code> and <code>Duration</code> types are derived from the actual
        <code>absTime</code> argument that is passed to th is member function, and
        should not explicitly be specified. This member function will try to
        obtain ownership of the <code>Mutex</code> object managed by the
        <code>unique_lock</code> object by calling the mutex's
        <code>mutex.try_lock_until(absTime)</code> member.</blockquote>
    <li><a name="an2300"></a><code>void unlock()</code>:<blockquote>releases ownership of the mutex (or reduces the mutex's lock count). A
        <code>system_error</code> exception is thrown if the <code>unique_lock</code> does not
        own the mutex.</blockquote>
    <li><a name="an2301"></a><code>Mutex *mutex() const noexcept</code>:<blockquote>returns a pointer to the mutex object stored inside the
        <code>unique_lock</code> (a <code>nullptr</code> is returned if no mutex object is
        currently stored inside the <code>unique_lock</code> object.)</blockquote>
    </ul>
<p>
Here is a simple example showing a <code>unique_lock</code> being used trying to obtain
ownership of a <code>timed_mutex</code>:
        <pre>
    std::timed_mutex dataMutex;
    Data data;

    void safeProcess()
    {
        std::unique_lock&lt;std::timed_mutex&gt;
            guard(dataMutex, std::chrono::milliseconds(3));
        if (guard)
            process(data);
    }
</pre>
    In the above example <code>guard</code> tries to obtain the lock during three
milliseconds. If <code>guard</code>'s <code>operator bool</code> returns <code>true</code> the lock was
obtained and <code>data</code> can be processed safely.
<p>
<a name="l347"></a>
<h4>18.8.4.1: Deadlocks</h4>
         Although they should be avoided, <a name="an2302"></a> <em>Deadlocks</em> are frequently
encountered in multi threaded programs. A deadlock occurs when two locks
are required to process data, but one thread obtains the first lock and
another thread obtains the second lock. The C++11 standard defines a generic
    <a name="an2303"></a><code>std::lock</code> function that can be used to help preventing
such situations. The <code>std::lock</code> function can be used to lock multiple
mutexes in one atomic action. Here is an example:
        <pre>
    struct SafeString
    {
        std::mutex  d_mutex;
        std::string d_text;
    };

    void calledByThread(SafeString &amp;first, SafeString &amp;second)
    {
        std::unique_lock&lt;std::mutex&gt;                        // 1
                lock_first(first.d_mutex, std::defer_lock);

        std::unique_lock&lt;std::mutex&gt;                        // 2
                lock_second(second.d_mutex, std::defer_lock);

        std::lock(lock_first, lock_second);                 // 3

        safeProcess(first.d_text, second.d_text);
    }
</pre>
    At 1 and 2 <code>unique_locks</code> are created. Locking is deferred until calling
<code>std::lock</code> at 3. Having obtained the lock, the two <code>SafeString</code> text
members can both be safely processed by <code>calledByThread</code>.
<p>
Another problematic issue with threads involves initialization. If multiple
threads are running and only the first thread calling the initialization code
should actually perform the initialization then this problem should not be
solved using mutexes. 
<p>
Although proper synchronization is realized, the synchronization is performed
time and again for every thread. The C++11 standard offers several ways to
perform a proper initialization:
    <ul>
    <li> First, suppose your constructor is declared with the <a name="an2304"></a><code>constexpr</code>
keyword (cf. section <a href="cplusplus08.html#CONSTEXPR">8.1.4.1</a>), satisfying the requirements for constant
initialization. In this case, an object of static storage lifetime,
initialized using that constructor, is guaranteed to be initialized before any
code is run as part of the static initialization phase. This is the option
chosen for <code>std::mutex</code>, because it eliminates the possibility of race
conditions with initialization of mutexes at a global scope. Here is an
example, using in-class implementations for brevity:
        <pre>
class MyClass
{
    int d_i;

    public:
        constexpr MyClass(int i = 0)
        :
            d_i(0)
        {}

    void action();
};

MyClass myObject;   // static initialization with constexpr constructor

int foo();
myClass other(42 + foo());  // dynamic initialization

void f()
{
    other.action();         // is other initialized in some thread?
}
</pre>
    <li> Second, a static variable defined within a compound statement may be
used (e.g., a static local variable within a function body).  In C++ static
variables <a name="an2305"></a> defined within a compound
statement are initialized the first time the function is called at the point
in the code where the static variable is defined as illustrated by the
following example:
        <pre>
        #include &lt;iostream&gt;

        struct Cons
        {
            Cons()
            {
                std::cout &lt;&lt; "Cons called\n";
            }
        };
        void called(char const *time)
        {
            std::cout &lt;&lt; time &lt;&lt; "time called() activated\n";
            static Cons cons;
        }
        int main()
        {
            std::cout &lt;&lt; "Pre-1\n";
            called("first");
            called("second");
            std::cout &lt;&lt; "Pre-2\n";
            Cons cons;
        }
    /*
        Displays:
            Pre-1
            firsttime called() activated
            Cons called
            secondtime called() activated
            Pre-2
            Cons called
    */
</pre>
    This feature causes a thread to wait automatically if another thread is
still initializing the static data (note that <em>non-static</em> data never cause
problems, as each non-static local variables have lifes that are completely
restricted to their own threads).
    <li> If the above two approaches can't be used. The combined use of
 <a name="an2306"></a><code>std::call_once</code> and <a name="an2307"></a> <code>std::once_flag</code> result
in one-time execution of a specified function as illustrated by the next
example:
        <pre>
std::string *global;
std::once_flag globalFlag;

void initializeGlobal()
{
    global = new std::string("Hello world (why not?)");
}
void safeUse()
{
    std::call_once(globalFlag, initializeGlobal);
    process(*global);
}
</pre>
    </ul>
<p>
<a name="l348"></a>
<h3>18.8.5: Event handling (condition variables)</h3>
    In this section <em>condition variables</em>, as defined by the standard template
library, are introduced. Condition variables allow programs to synchronize
threads using the <em>states</em> of data, rather than simply locking the
<em>access</em> to data (which is realized using mutexes).
<p>
Before condition variables can be used the <a name="an2308"></a><code>&lt;condition_variable&gt;</code> header
file must have been included.
<p>
To start our discussion, consider a classic producer-consumer scenario: the
producer generates items which are consumed by a consumer. The producer can
only produce a certain number of items before its storage capacity has filled
up and the client cannot consume more items than the producer has produced.
<p>
At some point the producer's storage capacity has filled to the brim, and the
producer has to wait until the client has at least consumed some items,
thereby creating space in the producer's storage. Similarly, the consumer
cannot start consuming until the producer has at least produced some items.
<p>
Implementing this scenario only using mutexes (data locking) is not an
attractive option, as merely using mutexes forces a program to implement the
scenario using <em>polling</em>: processes must continuously (re)acquire the
mutex's lock, determine whether they can perform some action, followed by the
release of the lock. Often there's no action to perform, and the process is
busy acquiring and releasing the mutex's lock. Polling forces threads to wait
until they can lock the mutex, even though continuation might already be
possible. The polling interval could be reduced, but that too isn't an
attractive option, as it results in needlessly increasing the overhead
associated with handling the associated mutexes (a situation also known as
`busy waiting').
<p>
Contrary to merely using mutexes, polling can be prevented using condition
variables. Using condition variables threads may <em>notify</em> waiting threads
that there is something for them to do. Thus threads synchronized on the
<em>states</em> (e.g., <em>values</em>) of data.
<p>
As the states of data may be modified by multiple threads, threads still need
to use mutexes, but merely to control access to the data.  In addition,
however, condition variables allow threads to release ownership of mutexes
until a certain state has been reached, until a preset amount of time has been
passed, or until a preset point in time has been reached.
<p>
The prototypical setup of threads using condition variables looks like this:
    <ul>
    <li> consumer thread(s) act like this:
        <pre>
    lock the mutex
    while the required condition is false:
        wait until being notified 
        (automatically releasing the mutex's lock).
    the mutex's lock has been reacquired, and the condition is true:
        process the data
    release the mutex's lock.
</pre>
    <li> producer thread(s) act similarly:
        <pre>
    lock the mutex
    while the condition is false:
        process the data
    notify waiting threads that the condition is true
    release the mutex's lock.
</pre>
    </ul> No matter which thread starts, the thread holding the mutex's lock will
at some point release the lock, allowing the other process to (re)acquire
it. If the consumer starts it immediately releases the lock once it enters its
waiting state; if the producer starts it releases the lock once the condition
is true. There is a slight initial synchronization requirement, though. The
producer's notification will be missed if the consumer hasn't yet entered its
waiting state. So waiting (consumer) threads should start before notifying
(producer) threads. One the threads have started, no assumptions can be made
about the order in which any of the <code>notify_one, notify_all, wait,
wait_for</code>, and <code>wait_until</code> members are executed.
<p>
Condition variables come in two flavors: objects of the class 
    <a name="an2309"></a><code>std::condition_variable</code> are used in combination
with objects of type <code>unique_lock&lt;mutex&gt;</code>. This allows for certain
optimizations resulting in an increased efficiency compared to the efficiency
that can be obtained with objects of the class
    <a name="an2310"></a><code>std::condition_variable_any</code>, which may be
used with any (e.g., user supplied) lock type.
<p>
Condition variable classes offer members like <code>wait, wait_for,
wait_until, notify_one</code> and <code>notify_all</code> that may concurrently be called.
The notifying members are always atomically executed. Execution of the
<code>wait</code> members consists of three atomic parts:
    <ul>
    <li> the mutex is released, and the thread is suspended until its
        notification; 
    <li> Once the notification has been received, the lock is reacquired
    <li> The wait state ends (and processing continues beyond the <code>wait</code>
        call). 
    </ul>
    So, returning from <code>wait</code>-members the previously waiting thread 
has reacquired the mutex's lock.
<p>
In addition to the condition variable classes the following free function and
<code>enum</code> type is provided:
    <ul>
    <li><a name="an2311"></a><code>void 
         std::notify_all_at_thread_exit(condition_variable+linebreak()
            &amp;cond, tt(unique_lock&lt;mutex&gt; lockObject))</code>:<blockquote>once the current thread has ended, all other threads waiting on
        <code>cond</code> are notified. It is good practice to exit the thread as
        soon as possible after calling 
        <code>notify_all_at_thread_exit</code>.
<p>
Waiting threads must verify that the thread they were waiting for has
        indeed ended. This is usually realized  by first obtaining the lock on
        <code>lockObject</code>, followed by verifying that the condition
        they were waiting for is true and that the lock was not
        reacquired before <code>notify_all_at_thread_exit</code> was called.</blockquote>
    <li><a name="an2312"></a><code>std::cv_status</code>:<blockquote>the <code>cv_status</code> enum is used by several member functions of the
condition variable classes (cf. sections <a href="cplusplus18.html#CONDVAR1">18.8.5.1</a> and <a href="cplusplus18.html#CONDVAR2">18.8.5.2</a>):
        <pre>
namespace std
{
    enum class cv_status 
    { 
        no_timeout, 
        timeout 
    };
}
</pre>
        </blockquote>
    </ul>
<p>
<a name="CONDVAR1"></a><a name="l349"></a>
<h4>18.8.5.1: The class 'condition_variable'</h4>
        The class <code>std::condition_variable</code><a name="an2313"></a> merely offers a
default constructor. No copy constructor or overloaded assignment operator are
provided.
<p>
Before using the class <code>condition_variable</code> the <a name="an2314"></a><code>&lt;condition_variable&gt;</code>
header file must have been included.
<p>
The class's destructor requires that no thread is blocked by the current
thread. This implies that all threads waiting on a <code>condition_variable</code> must
have been notified before a <code>condition_variable</code> object's lifetime
ends. Calling <code>notify_all</code> (see below) before a <code>condition_variable</code>
ceases to exists takes care of that.
<p>
In the following member-descriptions a type <code>Predicate</code> indicates that the
provided <code>Predicate</code> argument can be called as a function without arguments,
returning a <code>bool</code>. Also, other member functions are frequently referred
to. It is tacitly assumed that all member referred to below were called using
the same condition variable object.
<p>
The class <code>condition_variable</code> supports several <code>wait</code> members, which will
block the thread until notified by another thread (or after a configurabel
waiting time). However, these <code>wait</code> members may also spuriously unblock,
without having reacquired the lock. Therefore, returning from these <code>wait</code>
members threads should verify that the required data condition has actually
been met. If not, again calling <code>wait</code> may be appropriate, as illustrated by
the next piece of pseudo code:
       <pre>
    while (conditionNotYetMet())
        condVariable.wait(&amp;uniqueLock);
</pre>
<p>
The class <code>condition_variable</code>'s members are:
    <ul>
    <li><a name="an2315"></a><code>void notify_one() noexcept</code>:<blockquote>one <code>wait</code> member called by other threads returns. Which one
        actually returns cannot be predicted.</blockquote>
<p>
<li><a name="an2316"></a><code>void notify_all() noexcept</code>:<blockquote>all <code>wait</code> members called by other threads unblock their wait
        states. Of course, only one of them will subsequently succeed in
        reacquiring the condition variable's lock object.</blockquote>
<p>
<li><a name="an2317"></a><code>void wait(unique_lock&lt;mutex&gt;&amp; uniqueLock)</code>:<blockquote>before calling <code>wait</code> the current thread must have acquired the lock
        of <code>uniqueLock</code>. Calling <code>wait</code> releases the lock, and the current
        thread is blocked until it has received a notification from another
        thread, and has reacquired the lock.
<p>
Threads should verify that the required data condition has been met
        after <code>wait</code> has returned.</blockquote>
<p>
<li><code>void wait(unique_lock&lt;mutex&gt;&amp; uniqueLock, Predicate pred)</code>:<blockquote>this is a member template, using the template header <code>template
        &lt;typename Predicate&gt;</code>. 
       The template's type is automatically derived from the function's
        argument type and does not have to be specified explicitly.
<p>
Before calling <code>wait</code> the current thread must have acquired the lock
        of <code>uniqueLock</code>. As long as `<code>pred</code>' returns <code>false</code>
        <code>wait(lock)</code> is called.
<p>
Threads should verify that the required data condition has been met
        after <code>wait</code> has returned.</blockquote>
<p>
<li><a name="an2318"></a><code>cv_status wait_for(unique_lock&lt;mutex&gt; &amp;uniqueLock,
                      std::chrono::duration&lt;Rep, Period&gt; const &amp;relTime)</code>:<blockquote>this member is defined as a member template, using the template header
        <code>template &lt;typename Rep, typename Period&gt;</code>.  
       The template's types are automatically derived from the typs of the
        function's arguments and do not have to be specified explicitly.
       E.g., to wait for at most 5 seconds <code>wait_for</code> can be called like
        this:
       <pre>
cond.wait_for(&amp;unique_lock, std::chrono::seconds(5));
</pre>
       This member returns when being notified or when the time interval
        specified by <code>relTime</code> has passed.
<p>
When returning due to a timeout, <code>std::chrono::cv_status::timeout</code> is
        returned, otherwise <code>std::chrono::cv_status::no_timeout</code> is
        returned.
<p>
Threads should verify that the required data condition has been met
        after <code>wait_for</code> has returned.</blockquote>
<p>
<li><code>bool wait_for(unique_lock&lt;mutex&gt; &amp;uniqueLock,
                      chrono::duration&lt;Rep, Period&gt; const &amp;relTime, Predicate
                       pred)</code>:<blockquote>this member is defined as a member template, using the template
        header <code>template &lt;typename Rep, typename Period, typename
        Predicate&gt;</code>. 
       The template's types are automatically derived from the typs of the
        function's arguments and do not have to be specified explicitly.
<p>
As long as <code>pred</code> returns false, the previous <code>wait_for</code> member is
        called. If the previous member returns <code>cv_status::timeout</code>, then
        <code>pred</code> is returned, otherwise <code>true</code>.
<p>
Threads should verify that the required data condition has been met
        after <code>wait_for</code> has returned.</blockquote>
<p>
<li><a name="an2319"></a><code>cv_status wait_until(unique_lock&lt;mutex&gt;&amp; uniqueLock,
                        chrono::time_point&lt;Clock, Duration&gt; const &amp;absTime)</code>:<blockquote>this member is defined as a member template, using the template
        header <code>template &lt;typename Clock, typename Duration&gt;</code>. 
       The template's types are automatically derived from the typs of the
        function's arguments and do not have to be specified explicitly.
       E.g., to wait until 5 minutes after the current time <code>wait_until</code> can
        be called like this:
       <pre>
cond.wait_until(&amp;unique_lock, chrono::system_clock::now() +
                              std::chrono::minutes(5));
</pre>
       This function acts identically to the <code>wait_for(unique_lock&lt;mutex&gt;
        &amp;uniqueLock, chrono::duration&lt;Rep, Period&gt; const &amp;relTime)</code> member
        described earlier, but uses an absolute point in time, rather than a
        relative time specification. 
<p>
This member returns when being notified or when the time interval
        specified by <code>relTime</code> has passed.
       When returning due to a timeout, <code>std::chrono::cv_status::timeout</code> is
        returned, otherwise <code>std::chrono::cv_status::no_timeout</code> is
        returned.
<p>
Threads should verify that the required data condition has been met
        after <code>wait_until</code> has returned.</blockquote>
<p>
<li><code>bool wait_until(unique_lock&lt;mutex&gt; &amp;lock,
                  chrono::time_point&lt;Clock, Duration&gt; const &amp;absTime,
                  Predicate pred)</code>:<blockquote>this member is defined as a member template, using the template header
        <code>template &lt;typename Clock, typename Duration, typename Predicate&gt;</code>.
       The template's types are automatically derived from the types of the
        function's arguments and do not have to be specified explicitly.
<p>
As long as <code>pred</code> returns false, the previous <code>wait_until</code> member
        is called. If the previous member returns <code>cv_status::timeout</code>, then
        <code>pred</code> is returned, otherwise <code>true</code>. 
<p>
Threads should verify that the required data condition has been met
        after <code>wait_until</code> has returned.</blockquote>
    </ul>
<p>
<a name="CONDVAR2"></a><a name="l350"></a>
<h4>18.8.5.2: The class 'condition_variable_any'</h4>
        Different from the class <code>condition_variable</code> the class
    <a name="an2320"></a><code>std::condition_variable_any</code> can be used with
any (e.g., user supplied) lock type, and not just with the stl-provided
<code>unique_lock&lt;mutex&gt;</code>.
<p>
Before using the class <code>condition_variable_any</code> the <a name="an2321"></a><code>&lt;condition_variable&gt;</code>
header file must have been included.
<p>
The functionality that is offered by <code>condition_variable_any</code> is identical
to the functionality offered by the class <code>condition_variable</code>, albeit that
the lock-type that is used by <code>condition_variable_any</code> is not
predefined. The class <code>condition_variable_any</code> therefore requires the
specification of the lock-type that must be used by its objects.
<p>
In the interface shown below this lock-type is referred to as <a name="an2322"></a><code>Lock</code>. Most
of <code>condition_variable_any's</code> members are defined as member templates,
defining a <code>Lock</code> type as one of its parameters. The requirements of these
lock-types are identical to those of the stl-provided <code>unique_lock</code>, and
user-defined lock-type implementations should provide at least the interface
and semantics that is also provided by <code>unique_lock</code>.
<p>
This section merely presents the interface of the class
<code>condition_variable_any</code>. As its interface offers the same members as
<code>condition_variable</code> (allowing, where applicable, passing any lock-type
instead of just <code>unique_lock</code> to corresponding members), the reader is
referred to the previous section for a description of the semantics of the
class members.
<p>
Like <code>condition_variable</code>, the class <code>condition_variable_any</code> only
offers a default constructor. No copy constructor or overloaded assignment
operator are provided.
<p>
Also, like <code>condition_variable</code>, the class's destructor requires that no
thread is blocked by the current thread. This implies that all other (waiting)
threads must have been notified; those threads may, however, subsequently
block on the lock specified in their <code>wait</code> calls.
<p>
Note that, in addition to <code>Lock</code>, the types <code>Clock, Duration, Period,
Predicate,</code> and <code>Rep</code> are template types, defined just like the identically
named types mentioned in the previous section.
<p>
Assuming that <code>MyMutex</code> is a user defined mutex type, and that <code>MyLock</code> is
a user defined lock-type (cf. section <a href="cplusplus18.html#LOCKS">18.8.4</a> for details about
lock-types), then a <code>condition_variable_any</code> object can be defined and used
like this:
        <pre>
    MyMutex mut;
    MyLock&lt;MyMutex&gt; ul(mut);
    condition_variable_any cva;

    cva.wait(ul);
</pre>
<p>
Here are the class <code>condition_variable_any's</code> members:
    <ul>
    <li><a name="an2323"></a><code>void notify_one() noexcept;</code>
    <li><a name="an2324"></a><code>void notify_all() noexcept;</code>
    <li><a name="an2325"></a><code>void wait(Lock&amp; lock);</code>
    <li><code>void wait(Lock&amp; lock, Predicate pred);</code>
    <li><a name="an2326"></a><code>cv_status wait_until(Lock&amp; lock, const
        chrono::time_point&lt;Clock, Duration&gt;&amp; absTime);</code>
    <li><code>bool wait_until(Lock&amp; lock, const chrono::time_point&lt;Clock, Duration&gt;&amp;
        absTime, Predicate pred);</code> 
    <li><a name="an2327"></a><code>cv_status wait_for(Lock&amp; lock, const chrono::duration&lt;Rep,
        Period&gt;&amp; relTime);</code> 
    <li><code>bool wait_for(Lock&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp;
        relTime,)</code> <code>Predicate pred</code>; 
    </ul>
<p>
<a name="CONDEX"></a><a name="l351"></a>
<h4>18.8.5.3: An example using condition variables</h4>
        Condition variables are used to synchronize threads on the states (values) of
data, rather than on access to data (for which plain mutex-objects can be
used). Using condition variables, a thread simply sleeps until it is notified
by another thread. In a producer-consumer type of program this is usually
accomplished like this:
        <pre>
    producer loop:
        - produce the next item
        - wait until there's room to store the item,
            then reduce the available storage
        - store the item
        - increment the number of items in store

    consumer loop:
        - wait until there's an item in store,
            then reduce the number of items in store
        - remove the item from the store
        - increment the number of available storage locations
        - do something with the retrieved item
</pre>
<p>
It is important that the two storage administrative tasks (registering the
number of available items and available storage locations) are either
performed by the client or by the producer. `Waiting' in this case means:
    <ul>
    <li> Get a lock on the variable containing the actual count
    <li> As long as the count is zero: 
                wait, releasing the lock until another thread 
                      has increased the count, then
                      re-acquire the lock.
    <li> Reduce the count
    <li> Release the lock.
    </ul>
    This scheme is implemented using a <a name="an2328"></a><code>condition_variable</code>. The variable
containing the actual count is called <a name="an2329"></a><code>semaphore</code> and it can be protected
using, e.g. <code>mutex sem_mutex</code>. 
In addition a <code>condition_variable condition</code> is defined. The following code
uses three non-local variables:
        <pre>
    size_t semaphore;
    mutex sem_mutex;
    condition_variable condition;
</pre>
<p>
The waiting process is defined by the following function <code>down</code>:
        <pre>
    void down()
    {
        unique_lock&lt;mutex&gt; lock(sem_mutex);   // get the lock
        while (semaphore == 0)
            condition.wait(lock);           // see 1, below.
        --semaphore;                        // dec. semaphore count
    }                                       // the lock is released
</pre>
    At 1 <code>condition.wait</code> releases the lock, waits until receiving a
notification, and re-acquires the lock just before returning. Consequently,
<code>down</code>'s code always has complete and unique control over <code>semaphore</code>.
<p>
What about notifying the condition variable? This is handled by the
`increment the number ...' lines in the producer and consumer loops. These
parts are defined by the following <code>up</code> function:
        <pre>
    void up()
    {
        lock_guard&lt;std::mutex&gt; lock(sem_mutex); // get the lock
        if (semaphore++ == 0)
            condition.notify_one();             // see 2, below
    }                                           // the lock is released
</pre>
    At 2 <code>semaphore</code> is always incremented. However, by using a postfix
increment it is simultaneously tested for being zero. If it was initially zero
then <code>semaphore</code> is now one. Consequently, the thread waiting for
<code>semaphore</code> being unequal to zero may now continue. A waiting thread is
notified by calling <code>condition.notify_one</code>. In situations where multiple
threads are waiting `<a name="an2330"></a><code>notify_all</code>' can also be used.
<p>
Handling <code>semaphore</code> can nicely be encapsulated in a class
<code>Semaphore</code>, offering members <code>down</code> and <code>up</code>. For a more extensive
discussion of semaphores see <a name="an2331"></a>Tanenbaum, A.S. and <a name="an2332"></a>Austin, T. (2013)
    <a name="an2333"></a>Structured Computer Organization, Pearson Prentice-Hall.
<p>
Using the facilities of the class <code>Semaphore</code> whose constructor expects
an initial value of its <code>semaphore</code> data member, the classic producer and
consumer paradigm can now easily be implemented in the following
multi-threaded program&nbsp;(A more elaborate example of the
producer-consumer program is found in the <code>yo/stl/examples/events.cc</code> file
in the <strong>C++</strong> Annotations's source archive):
        <pre>
    Semaphore available(10);
    Semaphore filled(0);
    std::queue itemQueue;

    void producer()
    {
        size_t item = 0;
        while (true)
        {
            ++item;
            available.down();
            itemQueue.push(item);
            filled.up();
        }
    }
    void client()
    {
        while (true)
        {
            filled.down();
            size_t item = itemQueue.front();
            itemQueue.pop();
            available.up();
            process(item);      // not implemented here
        }
    }

    int main()
    {
        thread produce(producer);
        thread consume(consumer);

        produce.join();
        consume.join();
    }
</pre>
<p>
<a name="l352"></a>
<h2>18.9: Lambda expressions</h2>
The C++11 standard has added <a name="an2334"></a> <em>lambda expressions</em> to
the language. As we've seen generic algorithms often accept an argument that
can either be a function object or it can be a plain function. Examples are
the <code>sort</code> and <code>find_if</code> generic algorithms. When the function called by
the generic algorithm must remember its state a function object is
appropriate, otherwise a plain function can be used.
<p>
The function or function object is usually not readily available. Often it
must be defined in or near the location where the generic algorithm is used.
Usually this is accomplished by defining a class or function in the anonymous
namespace, passing an object of that class or passing that function to a
generic algorithm called from some other function. If the latter function is
itself a member function the need may be felt to grant the function called by
the generic algorithm access to other members of its class. Often this results
in a significant amount of code (defining the class), or it results in complex
code (to make available software elements that aren't automatically accessible
from the called function (object)). It may also result in code that is
irrelevant at the current level of specification. Nested classes don't solve
these problems and nested classes can't be used in templates.
<p>
A <a name="an2335"></a>lambda expression defines an
    <a name="an2336"></a>anonymous function object<a name="an2337"></a>, also called a
    <a name="an2338"></a><em>closure object</em>. When a lambda expression is evaluated it results in a
temporary object (the closure object). The type of a closure object is called
its <a name="an2339"></a><em>closure type</em>. 
<p>
Lambda expressions may be used inside blocks, classes or namespaces (i.e.,
pretty much anywhere you like). Their implied closure type is defined in the
smallest block, class or namespace scope which contains the lamba
expression. The closure object's visibility starts at its point of definition
and ends where its closure type ends.
<p>
The closure type defines a (<code>const</code>) public inline function call
operator. Here is an example of a lambda expression:
    <a name="an2340"></a>
    <a name="an2341"></a>
        <pre>
    []                      // the `lambda-introducer'
    (int x, int y)          // the `lambda-declarator'
    {                       // a normal compound-statement
        return x * y;
    }
</pre>
    The function call operator of the closure object created by this lambda
expression expects two <code>int</code> arguments and returns their product. It is an
inline <code>const</code> member of the closure type. To drop the <code>const</code> attribute,
the lamba expression should specify <code>mutable</code>, as follows:
        <pre>
    [](int x, int y) mutable
    ...
</pre>
    The lambda-declarator may be omitted, if it does not contain
parameters. The parameters in a lamba declarator may not be provided with
default arguments.
<p>
A closure object as defined by the above lamda expression could be used e.g.,
in combination with the <code>accumulate</code> generic algorithm to compute the
product of a series of <code>int</code> values stored in a vector:
        <pre>
    cout &lt;&lt; accumulate(vi.begin(), vi.end(), 1,
                [](int x, int y) { return x * y; });
</pre>
    The above lambda function uses the implicit return
        <a name="an2342"></a>
    type <code>decltype(x * y)</code>. An implicit return type can be used if the
lambda expression does not contain a <code>return</code> stattement (i.e., a void
lambda expression), if it contains a single <code>return</code> statement, or if it
contains multiple <code>return</code> statements returning values of identical types
(e.g., all <code>int</code> values). 
<p>
If there are multiple <code>return</code> statements returning values of different
types then the lambda expression's return type must specified be explicitly
using a
        <a name="an2343"></a><a name="an2344"></a>late-specified return type,
(cf. section <a href="cplusplus03.html#AUTO">3.3.5</a>):
        <pre>
    [](int x, int y) -&gt; int
    {
        if (y &lt; 0)
            return x / static_cast&lt;double&gt;(y);

        return z + x;
    }
</pre>
<p>
Variables that are visible at the location of a lambda expression can be
accessed by the lambda expression. How these variables are accessed depends on
the contents of the lambda-introducer (the area between the square brackets,
called the the <a name="an2345"></a><em>lambda-capture</em>). The lambda-capture allows passing a
    <a name="an2346"></a>local context to lambda expressions. 
<p>
Visible global and static variables as well as local variables defined in
the lambda expression's compound statement itself can directly be accessed
and, if applicable, modified. Example:
        <pre>
    int global;
    
    void fun()
    {
        []()  // [] may contain any specification
        { 
            int localVariable = 0;
            localVariable = ++global; 
        };
    }
</pre>
<p>
If the lambda expression is defined within a (non-static) class member
function then an initial <code>&amp;</code> or <code>=</code> character in the lambda-capture
enables <code>this</code>, allowing the lambda expression access to all class members
(data and functions).  The class's data members can be modified.
<p>
If the lambda expression is defined inside a function then that function's
local variables that are visible at the point of the lambda expression's
definition can be accessed by the lambda expression.
<p>
An initial <code>&amp;</code> character in the lambda-capture accesses these local
variables by reference. These variables can be modified from within the lambda
expression.
<p>
An initial <code>=</code> character in the lambda-capture creates a local copy of
the referred-to local variables. Furthermore, in this case the values of these
local copies can only be changed by the lambda expression if the lambda
expression is defined using the <code>mutable</code> keyword. E.g.,
        <pre>
    struct Class
    {
        void fun()
        {
            int var = 0;
            [=]() mutable
            {
                ++var;  // modifies the local
            }           // copy, not fun's var
        }
    }
</pre>
<p>
Fine-tuning is also possible. With an initial <code>=</code>, comma-separated
<code>&amp;var</code> specifications indicate that the mentioned local variables should be
processed by reference, rather than as copies; with an initial <code>&amp;</code>, comma
separated <code>var</code> specifications indicate that local copies should be used of 
the mentioned local variables. Again, these copies have immutable values
unless the lambda expression is provided with the <code>mutable</code> keyword. 
<p>
Here is an example:
        <pre>
    void showSum(vector&lt;int&gt; const &amp;vi)
    {
        int total = 0;
        for_each(
            vi.begin(), vi.end(),
            [&amp;](int x)
            {
                total += x;
            }
        );
        std::cout &lt;&lt; total &lt;&lt; '\n';
    }
</pre>
    The variable <code>int total</code> is passed to the lambda expression by reference
and is directly accessed by the function. Its parameter list merely defines an
<code>int x</code>, which is initialized in sequence by each of the values stored in
<code>vi</code>. Once the generic algorithm has completed <code>showSum</code>'s variable
<code>total</code> has received a value that is equal to the sum of all the vector's
values. It has outlived the lambda expression and its value is displayed.
<p>
Another fine-tuning consists of specifying <code>this</code> in the lambda-capture: it
also allows the lambda-expression to access the surrounding class members.
Example:
        <pre>
    class Data
    {
        std::vector&lt;std::string&gt; d_names;
        public:
            void show() const
            {
                int count = 0;
                std::for_each(d_names.begin(), d_names.end(),
                    [this, &amp;count](std::string const &amp;name)
                    {
                        std::cout &lt;&lt; ++count &lt;&lt; ' ' &lt;&lt;
                            capitalized(name) &lt;&lt; '\n';
                    }
                );
            }
        private:
            std::string capitalized(std::string name);
    };
</pre>
<p>
Lambda expressions may also be assigned to variables. An example of such
an assignment (using <code>auto</code> to define the variable's type) is:
        <pre>
    auto sqr = [](int x)
               {
                   return x * x;
               };
</pre>
    The lifetime of such lambda expressions is equal to the lifetime of the
variable receiving the lambda expression as its value. Named lambda functions
nicely fit in the niche of local functions: when a function needs to perform
some computations that are at a conceptually lower level than the function's
task itself, then it's attractive to encapsulate these computations in a
separate support function, and call the support function where needed.  A
support function can be defined in an anonymous namespace, but that quickly
becomes awkward when the requiring function is a class member, and the support
function needs access to the class's members as well. In that case a named
lambda expression can be used: it can be defined within the requiring
function, and may be given full access to the surrounding class. The name to
which the lambda expression is assigned becomes the name of a function which
can be called from the surrounding function. Here is an example, converting a
numeric IP address to a dotted decimal string, which can also be accessed
directly from an <code>Dotted</code> object (all implementations in-class to conserve
space):
        <pre>
    class Dotted
    {
        std::string d_dotted;
        
        public:
            std::string const &amp;dotted() const
            {
                return d_dotted;
            }
            std::string const &amp;dotted(size_t ip)
            {
                auto octet = 
                    [](size_t idx, size_t numeric)
                    {
                        return to_string(numeric &gt;&gt; idx * 8 &amp; 0xff);
                    };

                d_dotted = 
                        octet(3, ip) + '.' + octet(2, ip) + '.' +
                        octet(1, ip) + '.' + octet(0, ip);

                return d_dotted;
            }
    };
</pre>
<p>
Now that lambda expressions have been covered let's see how they can be used
to avoid spurious returns from <code>condition_variable's wait</code> calls
(cf. section <a href="cplusplus18.html#CONDEX">18.8.5.3</a>). According to the C++11 standard, condition
variables may spuriously return from <code>wait</code> calls. Therefore it is necessary
to check that the data are actually available once <code>wait</code> continues. 
<p>
The class <code>condition_variable</code> allows us to do that by offering <code>wait</code>
members expecting a lock <em>and</em> a predicate. The predicate checks the data's
state, and returns <code>true</code> if the data's state allows the data's
processing. Here is an alternative implementation of the <code>down</code> member shown
in section <a href="cplusplus18.html#CONDEX">18.8.5.3</a>, checking for the data's actual availability:
        <pre>
    void down()
    {
        unique_lock&lt;mutex&gt; lock(sem_mutex);
        condition.wait(lock, 
            [&amp;]()
            {
                return semaphore != 0
            }
        );
        --semaphore;
    }
</pre>
    The lambda expression ensures that <code>wait</code> only returns once
<code>semaphore</code> has been incremented.
<p>
<a name="l353"></a>
<h2>18.10: Randomization and Statistical Distributions</h2>
    Before the statistical distributions and accompanying random number
generators can be used the <a name="an2347"></a><code>&lt;random&gt;</code> header file must have been included.
<p>
The C++11 standard introduces several standard mathematical (statistical)
distributions into the STL. These distributions allow programmers to obtain
randomly selected values from a selected distribution.
<p>
These statistical distributions need to be provided with a random number
generating object. Several of such random number generating objects are
provided, extending the traditional <a name="an2348"></a><code>rand</code> function that is part of the
<strong>C</strong> standard library.
<p>
These random number generating objects produce pseudo-random numbers, which
are then processed by the statistical distribution to obtain values that are
randomly selected from the specified distribution.
<p>
Although the STL offers various statistical distributions their functionality
is fairly limited. The distributions allow us to obtain a random number from
these distributions, but
    <a name="an2349"></a>probability density functions
 or
    <a name="an2350"></a>cumulative distribution functions
 are currently not provided by the STL. These functions (distributions as well
as the density and the cumulative distribution functions) are, however,
available in other libraries, like the
    <a target=_top href="http://www.boost.org/">boost math library</a> (specifically:<br>
     <a href="http://www.boost.org/doc/libs/1_44_0/libs/math/doc/sf_and_dist/html/index.html">http://www.boost.org/doc/libs/1_44_0/libs/math/doc/sf_and_dist/html/index.html</a>).
<p>
It is beyond the scope of the <strong>C++</strong> Annotations to discuss the mathematical
characteristics of the various distributions that are supported by the C++11
standard. The interested reader is referred to the pertinent mathematical
textbooks (like Stuart and Ord's (2009)
    <a name="an2351"></a>
    <a name="an2352"></a><em>Kendall's Advanced Theory of Statistics</em>, Wiley) or to web-locations
like <a href="http://en.wikipedia.org/wiki/Bernoulli_distribution">http://en.wikipedia.org/wiki/Bernoulli_distribution</a>.
<p>
<a name="l354"></a>
<h3>18.10.1: Random Number Generators</h3>
    The following <a name="an2353"></a>generators are available:
<center>
<table>

<td colspan=5><hr></td>


<tr>
<td> Class template</td><td> Integral/Floating point</td><td> Quality</td><td> Speed</td><td> Size of state</td>
 
</tr>

<td colspan=5><hr></td>


<tr>
<td> <a name="an2354"></a><code>linear_congruential_engine</code></td><td> Integral</td><td> Medium</td><td> Medium</td><td> 1</td>
 
</tr>


<tr>
<td> <a name="an2355"></a><code>subtract_with_carry_engine</code></td><td> Both</td><td> Medium</td><td> Fast</td><td> 25</td>
 
</tr>


<tr>
<td> mersenne_twister_engine</td><td> Integral</td><td> Good</td><td> Fast</td><td> 624</td>
 
</tr>

<td colspan=5><hr></td>


</table></center>
<p>
The <a name="an2356"></a><code>linear_congruential_engine</code> random number generator computes
    <center><code>value</code><sub>i+1</sub><code> = (a * value</code><sub>i</sub><code> +
                                                              c) % m</code></center>
    It expects template arguments for, respectively, the data type to contain
the generated random values; the multiplier <code>a</code>; the additive constant
<code>c</code>; and the modulo value <code>m</code>. Example:
        <pre>
    linear_congruential_engine&lt;int, 10, 3, 13&gt; lincon;
</pre>
    The <code>linear_congruential</code> generator may be seeded by providing its
constructor with a seeding-argument. E.g., <code>lincon(time(0))</code>.
<p>
The <a name="an2357"></a><code>subtract_with_carry_engine</code> random number generator computes
    <center><code>value</code><sub>i</sub><code> = (value</code><sub>i-s</sub><code> -
                                                            value</code><sub>i-r</sub><code> - carry</code><sub>i-1</sub><code>) % m</code></center>
    It expects template arguments for, respectively, the data type to contain
the generated random values; the modulo value <code>m</code>; and the subtractive
constants <code>s</code> and <code>r</code>. Example:
        <pre>
    subtract_with_carry_engine&lt;int, 13, 3, 13&gt; subcar;
</pre>
    The <code>subtract_with_carry_engine</code> generator may be seeded by providing
its constructor with a seeding-argument. E.g., <code>subcar(time(0))</code>.
<p>
The predefined <code>mersenne_twister_engine mt19937</code> (predefined using a
<code>typedef</code> defined by the <a name="an2358"></a><code>&lt;random&gt;</code> header file) is used in the examples
below. It can be constructed using
    <a name="an2359"></a>`<code>mt19937 mt</code>' or it can be seeded by providing its
constructor with an argument (e.g., <code>mt19937 mt(time(0))</code>).
    Other ways to initialize the <code>mersenne_twister_engine</code> are beyond the
scope of the <strong>C++</strong> Annotations (but see Lewis<a name="an2360"></a> <em>et
al.</em>&nbsp;(
    Lewis, P.A.W., Goodman, A.S., and Miller, J.M. (1969), A pseudorandom
number generator for the System/360, IBM Systems Journal, 8, 136-146.) (1969)).
<p>
The random number generators may also be seeded by calling their members
<code>seed</code>  accepting <code>unsigned long</code> values or generator functions (as in
<code>lc.seed(time(0)), lc.seed(mt)</code>).
<p>
The random number generators offer members <a name="an2361"></a><code>min</code> and <a name="an2362"></a><code>max</code>
returning, respectively, their minimum and maximum values (inclusive). If a
reduced range is required the generators can be nested in a function or class
adapting the range.
<p>
<a name="l355"></a>
<h3>18.10.2: Statistical distributions</h3>
    In the following sections the various statistical distributions that are
supported by the C++11 standard are covered. The notation <a name="an2363"></a><code>RNG</code> is used to
indicate a <em>Random Number Generator</em> and <a name="an2364"></a><code>URNG</code> is used to indicate a
<em>Uniform Random Number Generator</em>. With each distribution a
<code>struct param_type</code> is defined containing the distribution's parameters. The
organization of these <code>param_type</code> structs depends on (and is described
at) the actual distribution.
<p>
All distributions offer the following members (<em>result_type</em> refers to
the type name of the values returned by the distribution):
    <ul>
    <li><code>result_type max() const</code><br>
        returns the distribution's least upper bound;
    <li><code>result_type min() const</code><br>
        returns the distribution's greatest lower bound;
    <li><code>param_type param() const</code><br>
        returns the object's <code>param_type</code> struct;
    <li><code>void param(const param_type &amp;param)</code>
        redefines the parameters of the distribution;
    <li><code>void reset():</code>
       clears all of its cached values;
    </ul>
<p>
All distributions support the following operators (<em>distribution-name</em>
        should be replaced by the name of the intended distribution, e.g.,
        <code>normal_distribution</code>):
    <ul>
    <li><code>template&lt;typename URNG&gt; result_type operator()(URNG &amp;urng)</code><br>
       returns the next random value from the statistical distribution, with
        the function object <code>urng</code> returning the next random number selected
        from a uniform random distribution;
    <li><code>template&lt;typename URNG&gt; result_type operator()</code><br>
       <code>(URNG &amp;urng, param_type &amp;param)</code><br> returns the next random value
        from the statistical distribution initialized with the parameters
        provided by the <code>param</code> struct.  The function object <code>urng</code>
        returns the next random number selected from a uniform random
        distribution;
    <li><code>std::istream &amp;operator&gt;&gt;(std::istream &amp;in,
            distribution-name &amp;object):</code>
       The parameters of the distribution are extracted from an
        <code>std::istream</code>;
    <li><code>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out,
            distribution-name const &amp;bd):</code>
        The parameters of the distribution are inserted into an
        <code>std::ostream</code>
    </ul>
<p>
The following example shows how the distributions can be used. Replacing
the name of the distribution (<code>normal_distribution</code>) by another
distribution's name is all that is required to switch distributions. All
distributions have parameters, like the mean and standard deviation of the
normal distribution, and all parameters have default values. The names of the
parameters vary over distributions and are mentioned below at the individual
distributions. Distributions offer members returning or setting their
parameters.
<p>
Most distributions are defined as class templates, requiring the specification
of a data type that is used for the function's return type. If so, an empty
template parameter type specification (<code>&lt;&gt;</code>) will get you the default
type. The default types are either <code>double</code> (for real valued return types)
or <code>int</code> (for integral valued return types). The template parameter type
specification must be omitted with distributions that are not defined as
template classes.
<p>
Here is an example showing the use of the statistical distributions, applied
to the normal distribution:
<p>
<pre>
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;random&gt;
using namespace std;

int main()
{
    std::mt19937 engine(time(0));
    std::normal_distribution&lt;&gt; dist;

    for (size_t idx = 0; idx &lt; 10; ++idx)
        std::cout &lt;&lt; "a random value: " &lt;&lt; dist(engine) &lt;&lt; "\n";

    cout &lt;&lt; '\n' &lt;&lt;
        dist.min() &lt;&lt; " " &lt;&lt; dist.max() &lt;&lt; '\n';
}
</pre>
<p>
<a name="BERNOULLI"></a><a name="l356"></a>
<h4>18.10.2.1: Bernoulli distribution</h4>
        The <a name="an2365"></a><code>bernoulli_distribution</code> is used to generate logical truth (boolean)
values with a certain probability <code>p</code>. It is equal to a binomial
distribution for one experiment (cf <a href="cplusplus18.html#BINOMIAL">18.10.2.2</a>).
<p>
The bernoulli distribution is <em>not</em> defined as a class template.
<p>
Defined types:
            <pre>
    typedef bool result_type;
    struct param_type
    {
      explicit param_type(double prob = 0.5);
      double p() const;                     // returns prob
    };
</pre>
<p>
Constructor and members:
    <ul>
    <li><code>bernoulli_distribution(double prob = 0.5)</code><br>
        constructs a bernoulli distribution with probability <code>prob</code> of
        returning <code>true</code>;
    <li><code>double p() const</code><br>
        returns <code>prob</code>;
    <li><code>result_type min() const</code><br>
        returns <code>false</code>;
    <li><code>result_type max() const</code><br>
        returns <code>true</code>;
    </ul>
<p>
<a name="BINOMIAL"></a><a name="l357"></a>
<h4>18.10.2.2: Binomial distribution</h4>
        The <a name="an2366"></a><code>binomial_distribution&lt;IntType = int&gt;</code> is used to determine the
probability of the number of successes in a sequence of <code>n</code> independent
success/failure experiments, each of which yields success with probability
<code>p</code>.
<p>
The template type parameter <code>IntType</code> defines the type of the generated
random value, which must be an integral type.
<p>
Defined types:
            <pre>
    typedef IntType result_type;
    struct param_type
    {
      explicit param_type(IntType trials, double prob = 0.5);
      IntType t() const;                    // returns trials
      double p() const;                     // returns prob
    };
</pre>
<p>
Constructors and members and example:
    <ul>
    <li><code>binomial_distribution&lt;&gt;(IntType trials = 1, double prob = 0.5)</code>
        constructs a binomial distribution for <code>trials</code> experiments, each
        having probability <code>prob</code> of success.
    <li><code>binomial_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a binomial distribution according to the values stored in
        the <code>param</code> struct.
    <li><code>IntType t() const</code><br>
        returns <code>trials</code>;
    <li><code>double p() const</code><br>
        returns <code>prob</code>;
    <li><code>result_type min() const</code> <br>
        returns 0;
    <li><code>result_type max() const</code><br>
        returns <code>trials</code>;
    </ul>
<p>
<a name="l358"></a>
<h4>18.10.2.3: Cauchy distribution</h4>
        The <a name="an2367"></a><code>cauchy_distribution&lt;RealType = double&gt;</code> looks similar to a normal
distribution. But cauchy distributions have heavier tails.  When studying
hypothesis tests that assume normality, seeing how the tests perform on data
from a Cauchy distribution is a good indicator of how sensitive the tests are
to heavy-tail departures from normality.
<p>
The mean and standard deviation of the Cauchy distribution are undefined.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType a = RealType(0),
                            RealType b = RealType(1));

        double a() const;
        double b() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code>cauchy_distribution&lt;&gt;(RealType a = RealType(0),
                            RealType b = RealType(1))</code>
        constructs a cauchy distribution with specified <code>a</code> and <code>b</code>
        parameters.
    <li><code>cauchy_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a cauchy distribution according to the values stored in
        the <code>param</code> struct.
    <li><code>RealType a() const</code><br>
        returns the distribution's <code>a</code> parameter;
    <li><code>RealType b() const</code><br>
        returns the distribution's <code>b</code> parameter;
    <li><code>result_type min() const</code><br>
        returns the smallest positive <code>result_type</code> value;
    <li><code>result_type max() const</code><br>
        returns the maximum value of <code>result_type</code>;
    </ul>
<p>
<a name="CHISQUARED"></a><a name="l359"></a>
<h4>18.10.2.4: Chi-squared distribution</h4>
        The <a name="an2368"></a><code>chi_squared_distribution&lt;RealType = double&gt;</code> with <code>n</code> degrees of
freedom is the distribution of a sum of the squares of <code>n</code> independent
standard normal random variables.
<p>
Note that even though the distribution's parameter <code>n</code> usually is an
integral value, it doesn't have to be integral, as the chi_squared
distribution is defined in terms of functions (<code>exp</code> and <code>Gamma</code>) that
take real arguments (see, e.g., the formula shown in the <code>&lt;bits/random.h&gt;</code>
header file, provided with the Gnu <code>g++</code> compiler distribution).
<p>
The chi-squared distribution is used, e.g., when testing the goodness of fit
of an observed distribution to a theoretical one.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType n = RealType(1));

        RealType n() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code>chi_squared_distribution&lt;&gt;(RealType n = 1)</code>
       constructs a chi_squared distribution with specified number of degrees
        of freedom.
    <li><code>chi_squared_distribution&lt;&gt;(param_type const &amp;param)</code>
       constructs a chi_squared distribution according to the value stored in
        the <code>param</code> struct;
    <li><code>IntType n() const</code><br>
        returns the distribution's degrees of freedom;
    <li><code>result_type min() const</code><br>
        returns 0;
    <li><code>result_type max() const</code><br>
        returns the maximum value of <code>result_type</code>;
    </ul>
<p>
<a name="l360"></a>
<h4>18.10.2.5: Extreme value distribution</h4>
        The <a name="an2369"></a><code>extreme_value_distribution&lt;RealType = double&gt;</code> is related to the
Weibull distribution and is used in statistical models where the variable of
interest is the minimum of many random factors, all of which can take positive
or negative values.
<p>
It has two parameters: a location parameter <code>a</code> and scale parameter <code>b</code>.
See also <br>
    <a target=_top href="http://www.itl.nist.gov/div898/handbook/apr/section1/apr163.htm">http://www.itl.nist.gov/div898/handbook/apr/section1/apr163.htm</a>
<p>
Defined types:
        <pre>
typedef RealType result_type;

struct param_type
{
    explicit param_type(RealType a = RealType(0),
                        RealType b = RealType(1));

    RealType a() const;     // the location parameter
    RealType b() const;     // the scale parameter
};
</pre>
<p>
Constructors and members:
    <ul>
    <li><code>extreme_value_distribution&lt;&gt;(RealType a = 0, RealType b = 1)</code>
        constructs an extreme value distribution with specified <code>a</code> and
        <code>b</code> parameters;
    <li><code>extreme_value_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs an extreme value distribution according to the values
        stored in the <code>param</code> struct.
    <li><code>RealType a() const</code><br>
        returns the distribution's location parameter;
    <li><code>RealType stddev() const</code><br>
        returns the distribution's scale parameter;
    <li><code>result_type min() const</code><br>
        returns the smallest positive value of <code>result_type</code>;
    <li><code>result_type max() const</code><br>
        returns the maximum value of <code>result_type</code>;
    </ul>
<p>
<a name="l361"></a>
<h4>18.10.2.6: Exponential distribution</h4>
        The <a name="an2370"></a><code>exponential_distribution&lt;RealType = double&gt;</code> is used to describe the
lengths between events that can be modelled with a homogeneous Poisson
process. It can be interpreted as the continuous form of the
geometric distribution.
<p>
Its parameter <code>prob</code> defines the distribution's <em>lambda</em> parameter, called
its <em>rate</em> parameter. Its expected value and standard deviation are both
<code>1 / lambda</code>.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType lambda = RealType(1));

        RealType lambda() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code>exponential_distribution&lt;&gt;(RealType lambda = 1)</code>
       constructs an exponential distribution with specified <code>lambda</code>
        parameter.
    <li><code>exponential_distribution&lt;&gt;(param_type const &amp;param)</code>
       constructs an exponential distribution according to the value stored in
        the <code>param</code> struct.
    <li><code>RealType lambda() const</code><br>
        returns the distribution's <code>lambda</code> parameter;
    <li><code>result_type min() const</code><br>
        returns 0;
    <li><code>result_type max() const</code><br>
        returns the maximum value of <code>result_type</code>;
    </ul>
<p>
<a name="l362"></a>
<h4>18.10.2.7: Fisher F distribution</h4>
        The <a name="an2371"></a><code>fisher_f_distribution&lt;RealType = double&gt;</code> is intensively used in
statistical methods like the Analysis of Variance. It is the distribution
resulting from dividing two <em>Chi-squared</em> distributions.
<p>
It is characterized by two parameters, being the degrees of freedom of the two
chi-squared distributions.
<p>
Note that even though the distribution's parameter <code>n</code> usually is an
integral value, it doesn't have to be integral, as the Fisher F distribution
is constructed from Chi-squared distributions that accept a non-integral
parameter value (see also section <a href="cplusplus18.html#CHISQUARED">18.10.2.4</a>).
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType m = RealType(1),
                            RealType n = RealType(1));

        RealType m() const; // The degrees of freedom of the nominator
        RealType n() const; // The degrees of freedom of the denominator
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code>fisher_f_distribution&lt;&gt;(RealType m = RealType(1),
                                RealType n = RealType(1))</code>
        constructs a fisher_f distribution with specified degrees of freedom.
    <li><code>fisher_f_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a fisher_f distribution according to the values stored in
        the <code>param</code> struct.
    <li><code>RealType m() const</code><br>
        returns the degrees of freedom of the nominator;
    <li><code>RealType n() const</code><br>
        returns the degrees of freedom of the denominator;
    <li><code>result_type min() const</code><br>
        returns 0;
    <li><code>result_type max() const</code><br>
        returns the maximum value of <code>result_type</code>;
    </ul>
<p>
<a name="l363"></a>
<h4>18.10.2.8: Gamma distribution</h4>
        The <a name="an2372"></a><code>gamma_distribution&lt;RealType = double&gt;</code> is used when working with data
that are not distributed according to the normal distribution. It is often
used to model waiting times.
<p>
It has two parameters, <code>alpha</code> and <code>beta</code>. Its expected value is <code>alpha
* beta</code> and its standard deviation is <code>alpha * beta</code><sup>2</sup>.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType alpha = RealType(1),
                            RealType beta = RealType(1));

        RealType alpha() const;
        RealType beta() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code>gamma_distribution&lt;&gt;(RealType alpha = 1, RealType beta = 1)</code>
        constructs a gamma distribution with specified <code>alpha</code> and <code>beta</code>
        parameters.
    <li><code>gamma_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a gamma distribution according to the values stored in
        the <code>param</code> struct.
    <li><code>RealType alpha() const</code><br>
        returns the distribution's <code>alpha</code> parameter;
    <li><code>RealType beta() const</code><br>
        returns the distribution's <code>beta</code> parameter;
    <li><code>result_type min() const</code><br>
        returns 0;
    <li><code>result_type max() const</code><br>
        returns the maximum value of <code>result_type</code>;
    </ul>
<p>
<a name="l364"></a>
<h4>18.10.2.9: Geometric distribution</h4>
        The <a name="an2373"></a><code>geometric_distribution&lt;IntType = int&gt;</code> is used to model the number
of bernoulli trials (cf. <a href="cplusplus18.html#BERNOULLI">18.10.2.1</a>) needed until the first success.
<p>
It has one parameter, <code>prob</code>, representing the probability of success in an
individual bernoulli trial.
<p>
Defined types:
        <pre>
    typedef IntType result_type;

    struct param_type
    {
        explicit param_type(double prob = 0.5);
        double p() const;
    };
</pre>
<p>
Constructors, members and example:
    <ul>
    <li><code>geometric_distribution&lt;&gt;(double prob = 0.5)</code>
        constructs a geometric distribution for bernoulli trials each having
        probability <code>prob</code> of success.
    <li><code>geometric_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a geometric distribution according to the values stored in
        the <code>param</code> struct.
    <li><code>double p() const</code><br>
        returns the distribution's <code>prob</code> parameter;
    <li><code>param_type param() const</code><br>
        returns the object's <code>param_type</code> structure;
    <li><code>void param(const param_type &amp;param)</code>
        redefines the parameters of the distribution;
    <li><code>result_type min() const</code><br>
        returns the distribution's lower bound (= <code>0</code>);
    <li><code>result_type max() const</code><br>
        returns the distribution's upper bound;
    <li><code>template&lt;typename URNG&gt; result_type operator()(URNG &amp;urng)</code><br>
        returns the next random value from the geometric distribution
    <li><code>template&lt;typename URNG&gt; result_type operator()</code><br>
        <code>(URNG &amp;urng, param_type &amp;param)</code><br>
        returns the next random value from a geometric distribution
        initialized by the provided <code>param</code> struct.
    <li> The random number generator that is passed to the generating
       functions must return integral values. Here is an example showing how
        the geometric distribution can be used:
        <pre>
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;random&gt;

int main()
{
    std::linear_congruential_engine&lt;unsigned, 7, 3, 61&gt; engine(0);

    std::geometric_distribution&lt;&gt; dist;

    for (size_t idx = 0; idx &lt; 10; ++idx)
        std::cout &lt;&lt; "a random value: " &lt;&lt; dist(engine) &lt;&lt; "\n";

    std::cout &lt;&lt; '\n' &lt;&lt;
        dist.min() &lt;&lt; " " &lt;&lt; dist.max() &lt;&lt; '\n';

}
</pre>
    </ul>
<p>
<a name="l365"></a>
<h4>18.10.2.10: Log-normal distribution</h4>
        The <a name="an2374"></a><code>lognormal_distribution&lt;RealType = double&gt;</code> is a probability
distribution of a random variable whose logarithm is normally distributed. If
a random variable <code>X</code> has a normal distribution, then <code>Y = e</code><sup>X</sup> has a
log-normal distribution.
<p>
It has two parameters, <em>m</em> and <em>s</em> representing, respectively, the mean
and standard deviation of <code>ln(X)</code>.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType m = RealType(0),
                            RealType s = RealType(1));

        RealType m() const;
        RealType s() const;
    };
</pre>
<p>
Constructor and members:
    <ul>
    <li><code>lognormal_distribution&lt;&gt;(RealType m = 0, RealType s = 1)</code>
       constructs a log-normal distribution for a random variable whose mean
        and standard deviation is, respectively, <code>m</code> and <code>s</code>.
    <li><code>lognormal_distribution&lt;&gt;(param_type const &amp;param)</code> constructs a
        log-normal distribution according to the values stored in the
        <code>param</code> struct.
    <li><code>RealType m() const</code><br>
        returns the distribution's <code>m</code> parameter;
    <li><code>RealType stddev() const</code><br>
        returns the distribution's <code>s</code> parameter;
    <li><code>result_type min() const</code><br>
        returns 0;
    <li><code>result_type max() const</code><br>
        returns the maximum value of <code>result_type</code>;
    </ul>
<p>
<a name="l366"></a>
<h4>18.10.2.11: Normal distribution</h4>
        The <a name="an2375"></a><code>normal_distribution&lt;RealType = double&gt;</code> is commonly used in science to
describe complex phenomena. When predicting or measuring variables, errors are
commonly assumed to be normally distributed.
<p>
It has two parameters, <em>mean</em> and <em>standard deviation</em>.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType mean = RealType(0),
                            RealType stddev = RealType(1));

        RealType mean() const;
        RealType stddev() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code>normal_distribution&lt;&gt;(RealType mean = 0, RealType stddev = 1)</code>
        constructs a normal distribution with specified <code>mean</code> and <code>stddev</code>
        parameters. The default parameter values define the
        <a name="an2376"></a><em>standard normal distribution</em>;
    <li><code>normal_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a normal distribution according to the values stored in
        the <code>param</code> struct.
    <li><code>RealType mean() const</code><br>
        returns the distribution's <code>mean</code> parameter;
    <li><code>RealType stddev() const</code><br>
        returns the distribution's <code>stddev</code> parameter;
    <li><code>result_type min() const</code><br>
        returns the lowest positive value of <code>result_type</code>;
    <li><code>result_type max() const</code><br>
        returns the maximum value of <code>result_type</code>;
    </ul>
<p>
<a name="l367"></a>
<h4>18.10.2.12: Negative binomial distribution</h4>
        The <a name="an2377"></a><code>negative_binomial_distribution&lt;IntType = int&gt;</code> probability distribution
describes the number of successes in a sequence of Bernoulli trials before a
specified number of failures occurs. For example, if one throws a die
repeatedly until the third time 1 appears, then the probability distribution
of the number of other faces that have appeared is a negative binomial
distribution.
<p>
It has two parameters: (<code>IntType</code>) k (&gt; 0), being the number of failures
until the experiment is stopped and (<code>double</code>) p the probability of success
in each individual experiment.
<p>
Defined types:
        <pre>
    typedef IntType result_type;

    struct param_type
    {
        explicit param_type(IntType k = IntType(1), double p = 0.5);

        IntType k() const;
        double p() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code>negative_binomial_distribution&lt;&gt;(IntType k = IntType(1),
                                                            double p = 0.5)</code>
       constructs a negative_binomial distribution with specified <code>k</code> and
        <code>p</code> parameters;
    <li><code>negative_binomial_distribution&lt;&gt;(param_type const &amp;param)</code>
       constructs a negative_binomial distribution according to the values
        stored in the <code>param</code> struct.
    <li><code>IntType k() const</code><br>
        returns the distribution's <code>k</code> parameter;
    <li><code>double p() const</code><br>
        returns the distribution's <code>p</code> parameter;
    <li><code>result_type min() const</code><br>
        returns 0;
    <li><code>result_type max() const</code><br>
        returns the maximum value of <code>result_type</code>;
    </ul>
<p>
<a name="l368"></a>
<h4>18.10.2.13: Poisson distribution</h4>
        The <a name="an2378"></a><code>poisson_distribution&lt;IntType = int&gt;</code> is used to model the probability
of a number of events occurring in a fixed period of time if these events
occur with a known probability and independently of the time since the last
event.
<p>
It has one parameter, <code>mean</code>, specifying the expected number of events in
the interval under consideration. E.g., if on average 2 events are observed in
a one-minute interval and the duration of the interval under study is
10 minutes then <code>mean = 20</code>.
<p>
Defined types:
        <pre>
    typedef IntType result_type;

    struct param_type
    {
        explicit param_type(double mean = 1.0);

        double mean() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code>poisson_distribution&lt;&gt;(double mean = 1)</code>
        constructs a poisson distribution with specified <code>mean</code>
        parameter.
    <li><code>poisson_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a poisson distribution according to the values stored in
        the <code>param</code> struct.
    <li><code>double mean() const</code><br>
        returns the distribution's <code>mean</code> parameter;
    <li><code>result_type min() const</code><br>
        returns 0;
    <li><code>result_type max() const</code><br>
        returns the maximum value of <code>result_type</code>;
    </ul>
<p>
<a name="l369"></a>
<h4>18.10.2.14: Student t distribution</h4>
        The <a name="an2379"></a><code>student_t_distribution&lt;RealType = double&gt;</code> is a probability
distribution that is used when estimating the mean of a normally distributed
population from small sample sizes.
<p>
It is characterized by one parameter: the degrees of freedom, which is equal
to the sample size - 1.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType n = RealType(1));

        RealType n() const;    // The degrees of freedom
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code>student_t_distribution&lt;&gt;(RealType n = RealType(1))</code>
        constructs a student_t distribution with indicated degrees of freedom.
    <li><code>student_t_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a student_t distribution according to the values stored in
        the <code>param</code> struct.
    <li><code>RealType n() const</code><br>
        returns the degrees of freedom;
    <li><code>result_type min() const</code><br>
        returns 0;
    <li><code>result_type max() const</code><br>
        returns the maximum value of <code>result_type</code>;
    </ul>
<p>
<a name="l370"></a>
<h4>18.10.2.15: Uniform int distribution</h4>
        The <a name="an2380"></a><code>uniform_int_distribution&lt;IntType = int&gt;</code> can be used to select integral
values randomly from a range of uniformly distributed integral values.
<p>
It has two parameters, <code>a</code> and <code>b</code>, specifying, respectively, the lowest
value that can be returned and the highest value that can be returned.
<p>
Defined types:
        <pre>
    typedef IntType result_type;

    struct param_type
    {
        explicit param_type(IntType a = 0, IntType b = max(IntType));

        IntType a() const;
        IntType b() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code>uniform_int_distribution&lt;&gt;(IntType a = 0, IntType b = max(IntType))</code>
        constructs a uniform_int distribution for the specified range of
        values.
    <li><code>uniform_int_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a uniform_int distribution according to the values stored in
        the <code>param</code> struct.
    <li><code>IntType a() const</code><br>
        returns the distribution's <code>a</code> parameter;
    <li><code>IntType b() const</code><br>
        returns the distribution's <code>b</code> parameter;
    <li><code>result_type min() const</code><br>
        returns the distribution's <code>a</code> parameter;
    <li><code>result_type max() const</code><br>
        returns the distribution's <code>b</code> parameter;
    </ul>
<p>
<a name="l371"></a>
<h4>18.10.2.16: Uniform real distribution</h4>
        The <a name="an2381"></a><code>uniform_real_distribution&lt;RealType = double&gt;</code> can be used to select
<code>RealType</code> values randomly from a range of uniformly distributed
<code>RealType</code> values.
<p>
It has two parameters, <code>a</code> and <code>b</code>, specifying, respectively, the
half-open range of values (<code>[a, b)</code>) that can be returned by the
distribution.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType a = 0, RealType b = max(RealType));

        RealType a() const;
        RealType b() const;
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code>uniform_real_distribution&lt;&gt;(RealType a = 0, RealType b = max(RealType))</code>
        constructs a uniform_real distribution for the specified range of
        values.
    <li><code>uniform_real_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a uniform_real distribution according to the values stored in
        the <code>param</code> struct.
    <li><code>RealType a() const</code><br>
        returns the distribution's <code>a</code> parameter;
    <li><code>RealType b() const</code><br>
        returns the distribution's <code>b</code> parameter;
    <li><code>result_type min() const</code><br>
        returns the distribution's <code>a</code> parameter;
    <li><code>result_type max() const</code><br>
        returns the distribution's <code>b</code> parameter;
    </ul>
<p>
<a name="l372"></a>
<h4>18.10.2.17: Weibull distribution</h4>
        The <a name="an2382"></a><code>weibull_distribution&lt;RealType = double&gt;</code> is commonly used in
reliability engineering and in survival (life data) analysis.
<p>
It has two or three parameters and the two-parameter variant is offered by the
STL. The three parameter variant has a shape (or slope) parameter, a scale
parameter and a location parameter. The two parameter variant implicitly uses
the location parameter value 0. In the two parameter variant the shape
parameter (a) and the scale parameter (b) are provided. See <br>
    <a target=_top href="http://www.weibull.com/hotwire/issue14/relbasics14.htm">http://www.weibull.com/hotwire/issue14/relbasics14.htm</a> for an
interesting coverage of the meaning of the Weibull distribution's parameters.
<p>
Defined types:
        <pre>
    typedef RealType result_type;

    struct param_type
    {
        explicit param_type(RealType a = RealType(1),
                            RealType b = RealType(1));

        RealType a() const;     // the shape (slope) parameter
        RealType b() const;     // the scale parameter
    };
</pre>
<p>
Constructors and members:
    <ul>
    <li><code>weibull_distribution&lt;&gt;(RealType a = 1, RealType b = 1)</code>
        constructs a weibull distribution with specified <code>a</code> and <code>b</code>
        parameters;
    <li><code>weibull_distribution&lt;&gt;(param_type const &amp;param)</code>
        constructs a weibull distribution according to the values stored in
        the <code>param</code> struct.
    <li><code>RealType a() const</code><br>
        returns the distribution's shape (or slope) parameter;
    <li><code>RealType stddev() const</code><br>
        returns the distribution's scale parameter;
    <li><code>result_type min() const</code><br>
        returns 0;
    <li><code>result_type max() const</code><br>
        returns the maximum value of <code>result_type</code>;
    </ul>
<p>

<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus17.html">Previous Chapter</a>
    <li> <a href="cplusplus19.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
