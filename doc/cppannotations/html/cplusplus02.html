<html>
<head>
<title>C++ Annotations Version 9.9.0</title>
</head>
<body text="black" bgcolor="white">
<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus01.html">Previous Chapter</a>
    <li> <a href="cplusplus03.html">Next Chapter</a>
</ul>
<hr>
<a name="IntroC"></a><a name="l2"></a>
<h1>Chapter 2: Introduction</h1>

<blockquote>
    <em>
        Don't hesitate to send in feedback: send an e-mail if you like the
        C++ Annotations; if you think that important material was omitted;
        if you find errors or typos in the text or the code examples;
        or if you just feel like e-mailing. Send your e-mail to
        <a href="mailto:f.b.brokken@rug.nl">Frank B. Brokken</a>.
<p>
<strong>Please</strong> state the document version you're referring to, as found in
        the title (in this document: 9.9.0) and please state chapter and
        paragraph name or number you're referring to.
<p>
All received mail is processed conscientiously, and received
        suggestions for improvements are usually processed by the
        time a new version of the Annotations is released. Except for the
        incidental case I will normally not acknowledge the receipt of
        suggestions for improvements. Please don't interpret this as me not
        appreciating your efforts.
    </em>
</blockquote>
<p>
This document offers an introduction to the <strong>C++</strong> programming language. It
is a guide for <strong>C/C++</strong> programming courses, yearly presented by Frank at the
University of Groningen. This document is not a complete <strong>C/C++</strong> handbook,
as much of the <strong>C</strong>-background of <strong>C++</strong> is not covered. Other sources
should be referred to for that (e.g., the Dutch book <em>De programmeertaal C</em>,
Brokken and Kubat, University of Groningen, 1996) or the
<a name="an3"></a>
 <a target=_top href="http://publications.gbdirect.co.uk/c_book/">on-line book</a> suggested to
me by George Danchev (danchev at spnet dot net).
<p>
The reader should be forwarned that extensive knowledge of the <strong>C</strong>
programming language is actually assumed. The <strong>C++</strong> Annotations continue where
topics of the <strong>C</strong> programming language end, such as pointers, basic flow
control and the construction of functions.
<p>
Some elements of the language, like specific lexical tokens (such as
<a name="an4"></a><em>trigraphs</em> (such as <code>??&lt;</code> for <code>{</code>, and using <code>??&gt;</code> for <code>}</code>)), and
<a name="an5"></a><em>bigraphs</em> (such as <code>&lt;:</code> for <code>[</code>, and <code>&gt;:</code> for <code>]</code>) are not covered
by the <strong>C++</strong> Annotations, as these tokens occur extremely seldom in <strong>C++</strong> source
code. The reader is referred to the document covering the C++11 standard for
an overview.
<p>
The version number of the <strong>C++</strong> Annotations (currently 9.9.0) is updated when
the contents of the document change. The first number is the major number, and
is probably not going to change for some time: it indicates a major
rewriting. The middle number is increased when new information is added to the
document. The last number only indicates small changes; it is increased when,
e.g., series of typos are corrected.
<p>
This document is published by the Center of Information Technology,
University of Groningen,
the Netherlands under the <a name="an6"></a>
 <a target=_top href="http://www.gnu.org/licenses/">GNU General Public License</a>.
<p>
The <strong>C++ Annotations</strong> were typeset using the <a name="an7"></a>
    <a name="an8"></a>
    <a target=_top href="http://yodl.sourceforge.net">yodl</a>
formatting system.
<p>
<blockquote>
    <strong>
        All correspondence concerning suggestions, additions, improvements or
        changes to this document should be directed to the author:
    </strong>
<p>
<strong>
        <center>Frank B. Brokken <br>
        Center of Information Technology,<br>
        University of Groningen <br>Nettelbosje 1,<br>P.O. Box 11044,<br>9700 CA Groningen <br>The Netherlands <br>
        (email: f.b.brokken@rug.nl)
        </center>
   </strong>
</blockquote>
<p>
In this chapter an overview of <strong>C++</strong>'s defining features is presented. A few
extensions to <strong>C</strong> are reviewed and the concepts of object based and object
oriented programming (OOP) are briefly introduced.
<p>
<a name="WHATSNEW"></a><a name="l3"></a>
<h2>2.1: What's new in the C++ Annotations</h2>
    This section is modified when the first or second part of the version number
changes (and sometimes for the third part as well).
    <ul>
    <li> In version 9.9.0 sections in chapter <a href="cplusplus18.html#STL">18</a> about  specifying
        absolute and relative time were rewritten and moved to sections of
        their own. Sections about condition variablles were also rewritten.
    <li> Version 9.8.0 adds new sections in chapter <a href="cplusplus21.html#TEMPCLASS">21</a> about
        static polymorphism, removes the concrete/a2x section, now made
        superfluous by string conversion functions, and removes the C++11
        indicators from section headers. The C++ standard has by now been
        implemented in Gnu's <code>g++</code> compiler (4.8.2). Note that the
        <code>--std=c++11</code> compiler flag is still necessary if you want the
        compiler to activate the C++11 extensions.
    <li> Version 9.7.0/9.7.1 adds several new sections (about time
        specifications, system_error, error_category, error_code, this_thread,
        locks) and other sections received a major overhaul (multi-threading,
        lambda expressions, the main function).
    <li> Version 9.6.0 adds a section about <code>noexcept</code>, deprecating
<code>throw</code> lists. Also the string chapter was updated.
    <li> Version 9.5.0 adapts the abstract containers to C++11, and adds a new
section (<code>Allocators</code>) just before introducing the sequential containers.
<code>make_shared</code>, combining <code>shared_ptr</code> and (new).
    <li> Version 9.4.0 adds a new section to chapter <a href="cplusplus18.html#STL">18</a> about
<code>make_shared</code>, combining <code>shared_ptr</code> and (new).
    <li> Version 9.3.0 refines the coverage of the <code>static_cast</code> and
<code>reinterpret_cast</code>, following a suggestion provided by Gido Schoenmacker.
    <li> There are two major differences between versions 9.2.0 and
9.1.0. First, unrestricted unions are covered in more detail (cf. section
<a href="cplusplus12.html#UNIONS">12.7</a>). Second, by now <a href="http://flexcpp.org/">flexc++</a> has been
released, and the sections previously using <code>flex</code> (cf. section
<a href="cplusplus23.html#BisonAndFlex">23.8</a>) are now using <code>flexc++</code>.
    <li> Version 9.1.0 adds several new sections describing elements of
the language that by now have been implemented in Gnu's <code>g++</code> compiler
version 4.7. In the Annotations's contents these sections are clearly marked
as <code>C++11, 4.7</code>. For section marked by merely C++11 it is assumed that
at least Gnu's compiler version 4.6 is available. Sections marked as <code>C++,
?</code> refer to elements in the C++11 (C++11) standard that haven't been
implemented yet in Gnu's <code>g++</code> compiler. Since C++11 is now the
`official' name of the new standard, references to C++0x have been replaced by
C++11.
<p>
Installation limits of various integral types are frequently obtained
using <code>#define</code>s set in the <code>&lt;climits&gt;</code> header file. However, the
<code>numeric_limits</code> template offers a (preferred) alternative, as
<code>numeric_limits</code> can also be used when defining templates. See chapter
<a href="cplusplus20.html#TEMPLATES">20</a> for details.
<p>
To the distribution's ./contributions directory I added Jurjen Bokma's
(jurjen dot bokma at rug dot nl) 'makebook' recipe for creating a neatly bound
C++ Annotations book. The result is fabulous! Thanks, Jurjen!
<p>
From now on, this `what's new' overview of changes to the Annotations is
restricted to the current and previous major release. Previous modifications
can be found in the distribution's <code>whatsnew.yo.old</code> file.
<p>
Finally, typos were repaired.
<p>
<li> Version 9.0.0 was released following an extensive discussion with
several members of the C++ standards committee about the form of move special
members (move constructors, move assignment operators, other functions
defining rvalue type parameters). This discussion, in particular the
discussions I had with Dave Abrahams, Jonathan Wakely and Herb Sutter
resulted, eventually, in the <strong>C++</strong> Annotations relaxing the principle of
const-correctness, and in modifying the declarations and implementations of
move special members in this release. This shift in position (adopted by the
<strong>C++</strong> Annotations since its very early releases) profoundly affects much of the
<strong>C++</strong> Annotations's contents, and warrants an upgrade to the next major release.
<p>
The principle of const-correctness has always been visible in the
<strong>C++</strong> Annotations, defining return values of arithmetic binary operators like
<code>operator+</code> as <code>const</code> return values. Here the <strong>C++</strong> Annotations also applied
another principle: `do as the ints do'. When (e.g.,) adding two <code>int</code>-values
the result is customarily considered immutable. I.e., <code>(a + 5) += 4</code> makes
no sense, with the compiler refusing to compile the statement. But is <code>a +
5</code> a constant? There is no simple answer to that question. Before the advent
of C++11 I thought the answer was `yes', but strangely enough, the answer was
not always `yes'. If the above <code>a</code> is of type <code>std::string</code> then <code>(a +
"b") += "c"</code> suddenly <em>is</em> accepted by the compiler. The <strong>C++</strong> Annotations never
adopted this scheme, but stuck to the rule `do as the ints do' by defining the
return types of functions returning values as <code>const</code> values.
<p>
C++11 added rvalue references to the language, and then I eventually was
convinced that defining  <code>const</code> return values should in general be
avoided. As C++11 allows temporaries to be associated with rvalue references,
a completely  new situation is created. Suddenly intermediate
<code>int</code> values <em>can</em> be modified, as illustrated by the following snippet of
code:
        <pre>
    void fun(int &amp;&amp;tmp)
    {
        tmp += 4;       // compiles OK
    }
    int main()
    {
        int a = 8;
        fun(a + 5);
    }
</pre>
    The snippet of code also shows the standard definition of an rvalue
reference as an entity of type `<code>Type &amp;&amp;</code>'. This definition of rvalue
reference parameters is now used all over the <strong>C++</strong> Annotations, together with
using non-const return types of functions returning values.
<p>
Many readers have submitted suggestions for improvements since version
8.3.1 was released. A big `thank you' to all of you, but in particular to
<strong>Francesco Poli</strong> who continued to send in suggestions for improvements for a
period of almost two years. His suggestions were an invaluable source of
improvement for almost every single section of the <strong>C++</strong> Annotations. Thanks,
Francesco, for all the effort you've put in improving this document!
<p>
Finally, in version 9.0.0 sections were added and sometimes moved. The
section about <em>unrestricted unions</em> was completed and moved to the
`Containers' chapter, and a new section about adding binary operators to
classes using function templates was added to the <strong>C++</strong> Annotations' final chapter
(concrete examples).
    <li> Version 8.3.1: usually a subminor version isn't explicitly
mentioned in this section, but in this case the changes from 8.3.0 to 8.3.1
were the result of many, many small and not so small corrections submitted by
Francesco Poli who did a very thorough close reading job on the
Annotations. Thanks again, Francesco, for all your contributions!
    <li> Version 8.3.0 adds sections about various (member) function adaptors
and adds/rephrases several sections about statistical distribution functions
(chapter <a href="cplusplus18.html#STL">18</a>). When covering elements from the C++-0x standard it is
assumed that the Gnu <code>g++</code> compiler version 4.4 is available. With elements
of the C++-0x standard requiring versions beyond 4.4 the required versions
are explicitly mentioned, if already known. All suggestions sent in by various
readers have also been processed, their help to improve the quality of the
<strong>C++</strong> Annotations is greatly appreciated: thanks!
    <li> Version 8.2.0 adds a section about casting <code>shared_ptrs</code> (section
<a href="cplusplus18.html#SHAREDCAST">18.4.5</a>) and about sharing arrays of objects (<a href="cplusplus18.html#SHAREDARRAY">18.4.6</a>).
    <li> Version 8.1.0 was released following a complete overhaul of the
<strong>C++</strong> Annotations, with two pre-leases in between. Many inconsistencies that had
crept into the text and examples were removed, streamlining the text and
synchronizing examples with the text.  All of the code examples have received
a work-over, replacing <code>endl</code> by <code>'\n'</code>, making virtual functions private,
etc., etc. The sections labeled C++11 were improved and sections showing
C++11 now also mention the <code>g++</code> version in which the new feature will
be made available, using <code>?</code> if this is as yet unknown. No version is shown
if the feature is already available in <code>g++</code> 4.3 (or in one of its
subreleases, like 4.3.3).  I received a host of suggestions from Francesco
Poli (thanks, Francesco (and several others), for all the effort you've put
into sending me those corrections).
    <li> Version 8.0.0 was released as a result of the upcoming new <strong>C++</strong>
standard&nbsp;(<a name="an9"></a><code>http://en.wikipedia.org/wiki/C++11</code>) becoming (partially)
available in the Gnu <code>g++</code>
    compiler&nbsp;(http://gcc.gnu.org/projects/cxx0x.html).
    Not all new elements of the new standard (informally called the C++0x
standard) are available right now, and new subreleases of the <strong>C++</strong>
Annotations will appear once more elements become implemented in the <code>g++</code>
compiler.  In section <a href="cplusplus02.html#COMPILATION">2.2.3</a> the way to activate the new standard is
shown, and new sections covering elements of the new standard show C++11
in their section-titles.
<p>
Furthermore, two new chapters were added: the STL chapter is now split
in two. The STL chapter now covers the STL except for the <em>Generic
Algorithms</em> which are now discussed in a separate chapter. Name spaces,
originally covered by the introductory chapter are now also covered in a
separate chapter.
    </ul>
<p>
<a name="l4"></a>
<h2>2.2: C++'s history</h2>
    The first implementation of <strong>C++</strong> was developed in the 1980s at
the AT&amp;T Bell Labs, where the Unix operating system was created.
<p>
<strong>C++</strong> was originally a `pre-compiler', similar to the preprocessor of <strong>C</strong>,
converting special constructions in its source code to plain <strong>C</strong>. Back then
this code was compiled by a standard <strong>C</strong> compiler. The `pre-code', which was
read by the <strong>C++</strong> pre-compiler, was usually located in a file with the
extension <code>.cc</code>, <code>.C</code> or <code>.cpp</code>. This file would then be converted to a
<strong>C</strong> source file with the extension <code>.c</code>, which was thereupon compiled and
linked.
<p>
The nomenclature of <strong>C++</strong> source files remains: the extensions <code>.cc</code> and
<code>.cpp</code> are still used. However, the preliminary work of a <strong>C++</strong>
pre-compiler is nowadays usually performed during the actual compilation
process. Often compilers determine the language used in a source file from its
extension. This holds true for Borland's and Microsoft's <strong>C++</strong> compilers,
which assume a <strong>C++</strong> source for an extension <code>.cpp</code>. The <a name="an10"></a>Gnu
<a name="an11"></a>compiler <a name="an12"></a><code>g++</code>, which is available on many Unix platforms, assumes for
<strong>C++</strong> the extension <code>.cc</code>.
<p>
The fact that <strong>C++</strong> used to be compiled into <strong>C</strong> code is also visible
from the fact that <strong>C++</strong> is a superset of <strong>C</strong>: <strong>C++</strong> offers the full
<strong>C</strong> grammar and supports all <strong>C</strong>-library functions, and adds to this
features of its own. This makes the transition from <strong>C</strong> to
<strong>C++</strong> quite easy. Programmers familiar with <strong>C</strong> may start
`programming in <strong>C++</strong>' by using source files having extensions <code>.cc</code> or
<code>.cpp</code> instead of <code>.c</code>, and may then comfortably slip into all the
possibilities offered by <strong>C++</strong>. No abrupt change of habits is required.
<p>
<a name="l5"></a>
<h3>2.2.1: History of the C++ Annotations</h3>
        The original version of the <strong>C++</strong> Annotations was written by Frank Brokken
and Karel Kubat in Dutch using <code>LaTeX</code>. After some time, Karel rewrote the
text and converted the guide to a more suitable format and (of course) to
English in september 1994.
<p>
The first version of the guide appeared on the net in october 1994. By then it
was converted to <code>SGML</code>.
<p>
Gradually new chapters were added, and the contents were modified and further
improved (thanks to countless readers who sent us their comment).
<p>
In major version four Frank added new chapters and converted the document from
SGML to <a target=_top href="http://yodl.sourceforge.net">yodl</a>.
    <blockquote>
    The <strong>C++</strong> Annotations are freely distributable. Be sure to read
    the <a href="legal.shtml">legal notes</a>.
<p>
<strong>Reading the annotations beyond this point implies that you are aware of
    these notes and that you agree with them.</strong>
    </blockquote>
    If you like this document, tell your friends about it. Even better, let us
know by sending email to <a href="mailto:f.b.brokken@rug.nl">Frank</a>.
<p>
In the <a name="an13"></a>Internet, many useful <a name="an14"></a>hyperlinks exist to <strong>C++</strong>. Without even
suggesting completeness (and without being checked regularly for existence:
they might have died by the time you read this), the following might be
worthwhile visiting:
    <ul>
    <li> <a name="an15"></a>
        <a target=_top href="http://www.cplusplus.com/ref/">http://www.cplusplus.com/ref/</a>: a reference site for <strong>C++</strong>.
<p>
<li> <a name="an16"></a>
        <a target=_top href="http://www.csci.csusb.edu/dick/c++std/cd2/index.html">http://www.csci.csusb.edu/dick/c++std/cd2/index.html</a>:
        offers a version
        of the 1996 working paper of the <strong>C++</strong> <a name="an17"></a>ANSI/ISO standard.
    </ul>
<p>
<a name="CppComp"></a><a name="l6"></a>
<h3>2.2.2: Compiling a C program using a C++ compiler</h3>
        Prospective <strong>C++</strong> programmers should realize that <strong>C++</strong> is not a perfect
superset of <strong>C</strong>. There are some differences you might encounter when you
simply rename a file to a file having the extension <code>.cc</code> and run it through
a <strong>C++</strong> compiler:
    <ul>
    <li> In <strong>C</strong>, <a name="an18"></a><code>sizeof</code><code>('c')</code> equals <code>sizeof(int)</code>, <code>'c'</code> being
any ASCII character.  The underlying philosophy is probably that <code>char</code>s,
when passed as arguments to functions, are passed as integers
anyway. Furthermore, the <strong>C</strong> compiler handles a character constant like
<code>'c'</code> as an integer constant. Hence, in <strong>C</strong>, the function calls
        <pre>
    putchar(10);
</pre>
    and
        <pre>
    putchar('\n');
</pre>
    are synonymous.
<p>
By contrast, in <strong>C++</strong>, <code>sizeof('c')</code> is always 1 (but see also section
<a href="cplusplus03.html#WCHAR">3.4.2</a>). An <code>int</code> is still an <code>int</code>, though. As we shall see later
(section <a href="cplusplus02.html#FunctionOverloading">2.5.4</a>), the two function calls
        <pre>
    somefunc(10);
</pre>
    and
        <pre>
    somefunc('\n');
</pre>
    may be handled by different functions: <strong>C++</strong> distinguishes functions not
only by their names, but also by their argument types, which are different in
these two calls. The former using an <code>int</code> argument, the latter a <code>char</code>.
    <li> <strong>C++</strong> requires very strict <a name="an19"></a>prototyping of external
functions. E.g., in <strong>C</strong> a prototype like
        <pre>
    void func();
</pre>
    means that a function <code>func()</code> exists, returning no value. The
declaration doesn't specify which arguments (if any) are accepted by the
function.
<p>
However, in <strong>C++</strong> the above declaration means that the function <code>func()</code>
does <em>not</em> accept any arguments at all. Any arguments passed to it
result in a compile-time error.
<p>
Note that the keyword <a name="an20"></a><code>extern</code> is not required when declaring functions. A
function definition becomes a function declaration simply by replacing a
function's body by a semicolon. The keyword <code>extern</code> <em>is</em> required,
though, when declaring variables.
    </ul>
<p>
<a name="COMPILATION"></a><a name="l7"></a>
<h3>2.2.3: Compiling a C++ program</h3>
        To compile a <strong>C++</strong> program, a <strong>C++</strong> <a name="an21"></a>compiler is required. Considering
the free nature of this document, it won't come as a surprise that a
 <a name="an22"></a><em>free compiler</em> is suggested here. The
 <a name="an23"></a>Free Software Foundation (<a name="an24"></a>FSF) provides at <a name="an25"></a>
 <a target=_top href="http://www.gnu.org">http://www.gnu.org</a> a free <strong>C++</strong>
compiler which is, among other places, also part of the <a name="an26"></a>Debian
 <a name="an27"></a>
 (<a target=_top href="http://www.debian.org">http://www.debian.org</a>) distribution of <a name="an28"></a>Linux
 (<a name="an29"></a> <a target=_top href="http://www.linux.org">http://www.linux.org</a>).
<p>
To use the features of the C++11 standard the <a name="an30"></a>compiler flag <a name="an31"></a><code>--std=c++11</code>
must currently be provided. In the <strong>C++</strong> Annotations it is assumed that this flag
is used when compiling the examples.
<p>
<a name="l8"></a>
<h4>2.2.3.1: C++ under MS-Windows</h4>
            For <a name="an32"></a>MS-Windows <a name="an33"></a>Cygnus <a name="an34"></a>
(<a target=_top href="http://sources.redhat.com/cygwin">http://sources.redhat.com/cygwin</a>) provides the foundation
for installing the <em>Windows port</em> of the <a name="an35"></a>Gnu <a name="an36"></a><code>g++</code> <a name="an37"></a>compiler.
<p>
When visiting the above URL to obtain a <a name="an38"></a> free <code>g++</code>
compiler, click on <code>install now</code>. This will download the file <a name="an39"></a><code>setup.exe</code>,
which can be run to install <code>cygwin</code>. The software to be installed can be
downloaded by <code>setup.exe</code> from the internet. There are alternatives (e.g.,
using a CD-ROM), which are described on the <a name="an40"></a>Cygwin page. Installation
proceeds interactively. The offered defaults are sensible and should be
accepted unless you have reasons to divert.
<p>
The most recent Gnu <code>g++</code> compiler can be obtained from
    <a name="an41"></a> <a target=_top href="http://gcc.gnu.org">http://gcc.gnu.org</a>. If the compiler that is
made available in the Cygnus distribution lags behind the latest version, the
sources of the latest version can be downloaded after which the compiler can
be built using an already available compiler. The compiler's webpage
(mentioned above) contains detailed instructions on how to proceed. In our
experience building a new compiler within the Cygnus environment works
flawlessly.
<p>
<a name="COMPSRC"></a><a name="l9"></a>
<h4>2.2.3.2: Compiling a C++ source text</h4>
            Generally the following command can be used to compile a <strong>C++</strong> source file
`<code>source.cc</code>':
        <pre>
        g++ source.cc
</pre>
    This produces a binary program (<code>a.out</code> or <code>a.exe</code>). If the default
name is inappropriate, the name of the executable can be specified using the
<code>-o</code> flag (here producing the program <code>source</code>):
        <pre>
        g++ -o source source.cc
</pre>
<p>
If a mere compilation is required, the compiled module can be produced using
the <code>-c</code> flag:
        <pre>
        g++ -c source.cc
</pre>
    This generates the file <code>source.o</code>, which can later on be linked to
other modules. As pointed out, provide the <a name="an42"></a>compiler option <a name="an43"></a>--std=c++11
(note: two dashes) to activate the features of the C++11 standard.
<p>
<strong>C++</strong> programs quickly become too complex to maintain `by hand'. With all
serious programming projects program maintenance tools are used. Usually the
standard <a name="an44"></a><code>make</code> program is used to maintain <strong>C++</strong> programs, but good
alternatives exist, like  the <a name="an45"></a>
        <a target=_top href="http://icmake.sourceforge.net/">icmake</a>
    or <a name="an46"></a> <a target=_top href="http://ccbuild.sourceforge.net/">ccbuild</a> program
maintenance utilities.
<p>
It is strongly advised to start using maintenance utilities early in the study
of <strong>C++</strong>.
<p>
<a name="Pretensions"></a><a name="l10"></a>
<h2>2.3: C++: advantages and claims</h2>
    Often it is said that programming in <strong>C++</strong> leads to `better' programs. Some
of the claimed advantages of <strong>C++</strong> are:
    <ul>
    <li> New programs would be developed in less time because old code can be
reused.
    <li> Creating and using new data types would be easier than in <strong>C</strong>.
    <li> The memory management under <strong>C++</strong> would be easier and more
transparent.
    <li> Programs would be less bug-prone, as <strong>C++</strong> uses a stricter syntax
and type checking.
    <li> <a name="an47"></a>`Data hiding', the usage of data by one program part
while other program parts cannot access the data, would be easier to implement
with <strong>C++</strong>.
    </ul>
    Which of these allegations are true? Originally, our impression was that
the <strong>C++</strong> language was somewhat overrated; the same holding true for the
entire object-oriented programming (OOP) approach. The enthusiasm for the
<strong>C++</strong> language resembles the once uttered allegations about
Artificial-Intelligence (AI) languages like <a name="an48"></a>Lisp and <a name="an49"></a>Prolog: these
languages were supposed to solve the most difficult AI-problems `almost
without effort'. New languages are often oversold: in the end, each problem
can be coded in any programming language (say <a name="an50"></a>BASIC or
    <a name="an51"></a>assembly language).  The advantages and disadvantages of a given
programming language aren't in `what you can do with them', but rather in
`which tools the language offers to implement an efficient and understandable
solution to a programming problem'. Often these tools take the form of
syntactic <a name="an52"></a><em>restrictions</em>, enforcing or promoting certain constructions or
which simply suggest intentions by applying or `embracing' such syntactic
forms. Rather than a long list of plain assembly instructions we now use flow
control statements, functions, objects or even (with <strong>C++</strong>) so-called
<em>templates</em> to structure and organize code and to express
oneself `eloquently' in the language of one's choice.
<p>
Concerning the above allegations of <strong>C++</strong>, we support the following, however.
    <ul>
    <li> The development of new programs while existing code is reused can
also be implemented in <strong>C</strong> by, e.g., using function libraries.  Functions
can be collected in a library and need not be re-invented with each new
program. <strong>C++</strong>, however, offers specific syntax possibilities for code
reuse, apart from function libraries (see chapters <a href="cplusplus13.html#INHERITANCE">13</a> and
<a href="cplusplus20.html#TEMPLATES">20</a>).
    <li> Creating and using new data types is certainly possible in <strong>C</strong>;
e.g., by using <code>struct</code>s, <code>typedef</code>s etc.. From these types other types
can be derived, thus leading to <code>struct</code>s containing <code>struct</code>s and so
on. In <strong>C++</strong> these facilities are augmented by defining data types which are
completely `self supporting', taking care of, e.g., their memory management
automatically (without having to resort to an independently operating memory
management system as used in, e.g., <strong>Java</strong>).
    <li> In <strong>C++</strong> memory management can in principle be either as easy or as
difficult as it is in C.  Especially when dedicated <strong>C</strong> functions such as
<code>xmalloc</code> and <code>xrealloc</code> are used (allocating the memory or aborting
the program when the memory pool is exhausted). However, with functions like
<code>malloc</code> it is easy to err. Frequently errors in <strong>C</strong> programs can be
traced back to  miscalculations when using <code>malloc</code>. Instead, <strong>C++</strong>
offers facilities to allocate memory in a somewhat safer way, using its
<code>operator new</code>.
    <li> Concerning `bug proneness' we can say that <strong>C++</strong> indeed uses
stricter type checking than <strong>C</strong>. However, most modern <strong>C</strong> compilers
implement `warning levels'; it is then the programmer's choice to disregard or
get rid of the warnings. In <strong>C++</strong> many of such warnings become fatal errors
(the compilation stops).
    <li> As far as `data hiding' is concerned, <strong>C</strong> does offer some tools.
E.g., where possible, local or <a name="an53"></a><code>static</code> variables can be used and special
data types such as <code>struct</code>s can be manipulated by dedicated functions.
Using such techniques, data hiding can be implemented even in <strong>C</strong>; though it
must be admitted that <strong>C++</strong> offers special syntactic constructions, making
it far easier to implement `data hiding' (and more in general:
`encapsulation') in <strong>C++</strong> than in <strong>C</strong>.
    </ul>
    <strong>C++</strong> in particular (and OOP in general) is of course not <em>the</em>
solution to all programming problems. However, the language <em>does</em> offer
various new and elegant facilities which are worth investigating. At the
downside, the level of grammatical complexity of <strong>C++</strong> has increased
significantly as compared to <strong>C</strong>. This may be considered a serious drawback
of the language. Although we got used to this increased level of complexity
over time, the transition was neither fast nor painless.
<p>
With the <strong>C++</strong> Annotations we hope to help the reader when transiting from <strong>C</strong>
to <strong>C++</strong> by focusing on the additions of <strong>C++</strong> as compared to <strong>C</strong> and by
leaving out plain <strong>C</strong>. It is our hope that you like this document and
may benefit from it.
<p>
Enjoy and good luck on your journey into <strong>C++</strong>!
<p>
<a name="OOP"></a><a name="l11"></a>
<h2>2.4: What is Object-Oriented Programming?</h2>
    Object-oriented (and object-based) programming propagates a slightly different
approach to programming problems than the strategy usually used in <strong>C</strong>
programs. In <strong>C</strong> programming problems are usually solved using a
`<a name="an54"></a>procedural approach': a problem is decomposed into subproblems and this
process is repeated until the subtasks can be coded. Thus a conglomerate of
functions is created, communicating through arguments and variables, global or
local (or <code>static</code>).
<p>
In contrast (or maybe better: in addition) to this, an object-based approach
identifies the <strong>keywords</strong> used in a problem statement. These keywords are
then depicted in a diagram where arrows are drawn between those keywords to
depict an internal hierarchy. The keywords become the objects in the
implementation and the hierarchy defines the relationship between these
objects. The term object is used here to describe a limited, well-defined
structure, containing all information about an entity: data types and
functions to manipulate the data. As an example of an
  <a name="an55"></a>object oriented approach, an illustration follows:
    <blockquote>
    The employees and owner of a car dealer and auto garage company are paid
    as follows. First, mechanics who work in the garage are paid a certain sum
    each month. Second, the owner of the company receives a fixed amount each
    month. Third, there are car salesmen who work in the showroom and receive
    their salary each month plus a bonus per sold car. Finally, the company
    employs second-hand car purchasers who travel around; these employees
    receive their monthly salary, a bonus per bought car, and a restitution of
    their travel expenses.
    </blockquote>
    When representing the above salary administration, the keywords could be
mechanics, owner, salesmen and purchasers. The properties of such units are: a
monthly salary, sometimes a bonus per purchase or sale, and sometimes
restitution of travel expenses. When analyzing the problem in this manner we
arrive at the following representation:
    <ul>
    <li> The owner and the mechanics can be represented by identical types,
receiving a given salary per month. The relevant information for such a type
would be the monthly amount. In addition this object could contain data as the
name, address and social security number.
    <li> Car salesmen who work in the showroom can be represented as the same
type as above but with some <em>extra</em> functionality: the number of
transactions (sales) and the bonus per transaction.
<p>
In the hierarchy of objects we would define the dependency between the
first two objects by letting the car salesmen be `derived' from
the owner and mechanics.
    <li> Finally, there are the second-hand car purchasers. These share the
functionality of the salesmen except for travel expenses. The additional
functionality would therefore consist of the expenses made and this type would
be derived from the salesmen.
    </ul>
    The hierarchy of the identified objects are further illustrated in
Figure <a href="cplusplus02.html#objects">1</a>.
    <a name="objects"></a><p><center><img src="intro/objects.gif" align="bottom" alt="Figure 1 is shown here."/><br>
Figure 1: Hierarchy of objects in the salary administration.
</center><p><br>

<p>
The overall process in the definition of a hierarchy such as the above starts
with the description of the most simple type. Traditionally (and still in
vogue with some popular object oriented languages) more complex types are then
derived from the basic set, with each derivation adding a little extra
functionality. From these derived types, more complex types can be derived
<em>ad infinitum</em>, until a representation of the entire problem can be
made. Over the years, however, this approach has become less popular in
<strong>C++</strong> as it typically results in overly tight <a name="an56"></a><em>coupling</em>, which in turns
<em>reduces</em> rather than enhances the understanding, maintainability and
testability of complex programs. In <strong>C++</strong> object oriented program more and
more favors small, easy to understand hierarchies, limited coupling and a
developmental process where <a name="an57"></a><em>design patterns</em> (cf. <em>Gamma et al.</em>
(1995)) play a central role.
<p>
Nonetheless, in <strong>C++</strong> <a name="an58"></a> <em>classes</em> are frequently used to define
the characteristics of <em>objects</em>. Classes contain the necessary
functionality to do useful things. Classes generally do not offer all their
functionality (and typically <em>none</em> of their data)
to objects of other classes. As we will see, classes tend to <em>hide</em> their
properties in such a way that they are not directly modifiable by the outside
world. Instead, dedicated functions are used to reach or modify the properties
of objects. Thus class-type objects are able to uphold their own
integrity. The core concept here is <a name="an59"></a><em>encapsulation</em> of which
  <a name="an60"></a><em>data hiding</em> is just an example. These concepts are further
explained in chapter <a href="cplusplus07.html#Classes">7</a>.
<p>
<a name="l12"></a>
<h2>2.5: Differences between C and C++</h2>
    In this section some examples of <strong>C++</strong> code are shown. Some differences
between <strong>C</strong> and <strong>C++</strong> are highlighted.
<p>
<a name="l13"></a>
<h3>2.5.1: The function `main'</h3>
        In <strong>C++</strong> there are only two variants of the function <a name="an61"></a><code>main</code>:
<code>int main()</code> and <code>int main(int argc, char **argv)</code>. 
<p>
Notes:
    <ul>
    <li> The return type of <code>main</code> is <code>int</code>, and <em>not</em> <code>void</code>;
    <li> The function <code>main</code> cannot be overloaded (for other than the
abovementioned signatures);
    <li> It is <em>not</em> required to use an explicit <code>return</code> statement at the
end of  <code>main</code>. If omitted <code>main</code> returns 0;
    <li> The value of <code>argv[argc]</code> equals 0;
    <li> The `third <code>char **envp</code> parameter' is not defined by the <strong>C++</strong>
standard and should be avoided.  Instead, the global variable <a name="an62"></a>
<code>extern char **environ</code> should be declared providing access to the program's
environment variables. Its final element has the value 0;
    <li> A <strong>C++</strong> program ends normally when the <code>main</code> function
returns. Using a <em>function try block</em> (cf. section <a href="cplusplus10.html#FUNTRY">10.11</a>) for <code>main</code>
is also considered a normal end of a <strong>C++</strong> program. When a <strong>C++</strong> ends
normally, destructors (cf. section <a href="cplusplus09.html#DESTRUCTOR">9.2</a>) of globally defined
objects are activated. A function like <strong>exit</strong>(3) does not normally end
a <strong>C++</strong> program and using such functions is therefore deprecated.
    </ul>
<p>
<a name="l14"></a>
<h3>2.5.2: End-of-line comment</h3>
        According to the <a name="an63"></a>ANSI/ISO definition, `<a name="an64"></a>end of line comment' is
implemented in the syntax of <strong>C++</strong>. This comment starts with <a name="an65"></a><code>//</code> and ends
at the end-of-line marker. The standard <strong>C</strong> comment, delimited by <code>/*</code> and
<code>*/</code> can still be used in <strong>C++</strong>:
        <pre>
    int main()
    {
        // this is end-of-line comment
        // one comment per line

        /*
            this is standard-C comment, covering
            multiple lines
        */
    }
</pre>
    Despite the example, it is advised <em>not</em> to use <strong>C</strong> type comment
inside the body of <strong>C++</strong> functions. Sometimes existing code must temporarily
be suppressed, e.g., for testing purposes. In those cases it's very practical
to be able to use standard <strong>C</strong> comment. If such suppressed code itself
contains such comment, it would result in nested comment-lines, resulting in
compiler errors. Therefore, the <a name="an66"></a>rule of thumb is not to use <strong>C</strong> type
comment inside the body of <strong>C++</strong> functions (alternatively, <code>#if 0</code> until
<code>#endif</code> pair of preprocessor directives could of course also be used).
<p>
<a name="l15"></a>
<h3>2.5.3: Strict type checking</h3>
        <strong>C++</strong> uses very strict <a name="an67"></a>type checking. A prototype must be known for each
function before it is called, and the call must match the prototype.
The program
        <pre>
    int main()
    {
        printf("Hello World\n");
    }
</pre>
 often compiles under <strong>C</strong>, albeit with a warning that <a name="an68"></a><code>printf()</code> is an
unknown function. But <strong>C++</strong> compilers (should) fail to produce code in such
cases. The error is of course caused by the missing <a name="an69"></a>
 <code>#include &lt;stdio.h&gt;</code> (which in <strong>C++</strong> is more commonly included as
 <a name="an70"></a> <code>#include &lt;cstdio&gt;</code> directive).
<p>
And while we're at it: as we've seen in <strong>C++</strong> <a name="an71"></a><code>main</code> <em>always</em> uses
the <code>int</code> <a name="an72"></a>return value. Although it is possible to define <a name="an73"></a><code>int
main()</code> without explicitly defining a return statement, within <code>main</code> it is
not possible to use a <code>return</code> statement without an explicit
<code>int</code>-expression.  For example:
        <pre>
    int main()
    {
        return;     // won't compile: expects int expression, e.g.
                    // return 1;
    }
</pre>
<p>
<a name="FunctionOverloading"></a><a name="l16"></a>
<h3>2.5.4: Function Overloading</h3>
        In <strong>C++</strong> it is possible to define
    <a name="an74"></a>functions having identical names but performing different actions. The
functions must differ in their <a name="an75"></a> parameter lists (and/or in
their <a name="an76"></a> <code>const</code> attribute). An example is given
below:
        <pre>
    #include &lt;stdio.h&gt;

    void show(int val)
    {
        printf("Integer: %d\n", val);
    }

    void show(double val)
    {
        printf("Double: %lf\n", val);
    }

    void show(char const *val)
    {
        printf("String: %s\n", val);
    }

    int main()
    {
        show(12);
        show(3.1415);
        show("Hello World!\n");
    }
</pre>
    In the above program three functions <code>show</code> are defined, only differing
in their parameter lists, expecting an <code>int</code>, <code>double</code> and <code>char *</code>,
respectively. The functions have identical names. Functions having identical
names but different parameter lists are called <em>overloaded</em>. The act of
defining such functions is called `<a name="an77"></a>function overloading'.
<p>
The <strong>C++</strong> compiler implements function overloading in a rather simple
way. Although the functions share their names (in this example <code>show</code>), the
compiler (and hence the linker) use quite different names. The conversion of a
name in the source file to an internally used name is called
 `<a name="an78"></a>name mangling'. E.g., the <strong>C++</strong> compiler might convert the prototype
<code>void</code> <code>show</code> <code>(int)</code> to the internal name <code>VshowI</code>, while an
analogous function having a <code>char *</code> argument might be called
<code>VshowCP</code>. The actual names that are used internally depend on the compiler
and are not relevant for the programmer, except where these names show up in
e.g., a listing of the contents of a library.
<p>
Some additional remarks with respect to  function overloading:
    <ul>
    <li> Do not use function overloading for functions doing conceptually
different tasks.  In the example above, the functions <code>show</code> are still
somewhat related (they print information to the screen).
<p>
However, it is also quite possible to define two functions <code>lookup</code>,
one of which would find a name in a list while the other would determine the
video mode. In this case the behavior of those two functions have nothing in
common. It would therefore be more practical to use names which suggest their
actions; say, <code>findname</code> and <code>videoMode</code>.
    <li> <strong>C++</strong> does not allow identically named functions to differ only in
their return values, as it is always the programmer's choice to either use or
ignore a function's  return value. E.g., the fragment
    <pre>
printf("Hello World!\n");
</pre>
    provides no information about the return value of the function
<code>printf</code>. Two functions <code>printf</code> which only differ in their
return types would therefore not be distinguishable to the compiler.
    <li> In chapter <a href="cplusplus07.html#Classes">7</a> the notion of <code>const</code> member functions is
introduced (cf. section <a href="cplusplus07.html#ConstFunctions">7.7</a>). Here it is merely mentioned
that classes normally have so-called member functions associated with them
(see, e.g., chapter <a href="cplusplus05.html#String">5</a> for an informal introduction to the
concept). Apart from
    <a name="an79"></a>
    overloading member functions using different parameter lists, it
is then also possible to
    <a name="an80"></a>
    overload member functions by their <code>const</code> attributes. In those cases,
classes may have pairs of identically named member functions, having identical
parameter lists. Then, these functions are overloaded by their <code>const</code>
attribute. In such cases only one of these function must have the <code>const</code>
attribute.
    </ul>
<p>
<a name="l17"></a>
<h3>2.5.5: Default function arguments</h3>
        In <strong>C++</strong> it is possible to provide `<a name="an81"></a>default arguments' when defining a
function. These arguments are supplied by the compiler when they are not
specified by the programmer. For example:
        <pre>
    #include &lt;stdio.h&gt;

    void showstring(char *str = "Hello World!\n");

    int main()
    {
        showstring("Here's an explicit argument.\n");

        showstring();           // in fact this says:
                                // showstring("Hello World!\n");
    }
</pre>
    The possibility to omit arguments in situations where default arguments
are defined is just a nice touch: it is the compiler who supplies the lacking
argument unless it is explicitly specified at the call. The code of the
program will neither be shorter nor more efficient when default arguments are
used.
<p>
Functions may be defined with more than one default argument:
        <pre>
    void two_ints(int a = 1, int b = 4);

    int main()
    {
        two_ints();            // arguments:  1, 4
        two_ints(20);          // arguments: 20, 4
        two_ints(20, 5);       // arguments: 20, 5
    }
</pre>
    When the function <code>two_ints</code> is called, the compiler supplies one or two
arguments whenever necessary. A statement like <code>two_ints(,6)</code> is, however,
not allowed: when arguments are omitted they must be on the right-hand side.
<p>
Default arguments must be known at <a name="an82"></a>compile-time since at that moment
arguments are supplied to functions. Therefore, the default arguments must be
mentioned at the function's <em>declaration</em>, rather than at its
<em>implementation</em>:
        <pre>
    // sample header file
    extern void two_ints(int a = 1, int b = 4);

    // code of function in, say, two.cc
    void two_ints(int a, int b)
    {
        ...
    }
</pre>
    It is an error to supply default arguments in function definitions. When
the function is used by other sources the compiler reads the header file
rather than the function definition. Consequently the compiler has no way to
determine the values of default function arguments. Current compilers generate
compile-time errors when detecting default arguments in function definitions.
<p>
<a name="l18"></a>
<h3>2.5.6: NULL-pointers vs. 0-pointers and nullptr</h3>
        In <strong>C++</strong> all zero values are coded as <code>0</code>. In <strong>C</strong> <a name="an83"></a><code>NULL</code> is often used
in the context of pointers. This difference is purely stylistic, though one
that is widely adopted. In <strong>C++</strong> <code>NULL</code> should be avoided (as it is a
<a name="an84"></a>macro, and macros can --and therefore should-- easily be avoided in
<strong>C++</strong>, see also section <a href="cplusplus08.html#GENCONST">8.1.4</a>). Instead <code>0</code> can almost always be
used.
<p>
Almost always, but not always. As <strong>C++</strong> allows function overloading
(cf. section <a href="cplusplus02.html#FunctionOverloading">2.5.4</a>) the programmer might be confronted with
an unexpected function selection in the situation shown in section
<a href="cplusplus02.html#FunctionOverloading">2.5.4</a>:
        <pre>
    #include &lt;stdio.h&gt;

    void show(int val)
    {
        printf("Integer: %d\n", val);
    }

    void show(double val)
    {
        printf("Double: %lf\n", val);
    }

    void show(char const *val)
    {
        printf("String: %s\n", val);
    }

    int main()
    {
        show(12);
        show(3.1415);
        show("Hello World!\n");
    }
</pre>
<p>
In this situation a programmer intending to call <code>show(char const *)</code> might
call <code>show(0)</code>. But this doesn't work, as 0 is interpreted as <code>int</code> and so
<code>show(int)</code> is called. But calling <code>show(NULL)</code> doesn't work either, as
<strong>C++</strong> usually defines <a name="an85"></a><code>NULL</code> as 0, rather than <code>((void *)0)</code>. So,
<code>show(int)</code> is called once again. To solve these kinds of problems the new
<strong>C++</strong> standard introduces the keyword <a name="an86"></a><code>nullptr</code> representing the 0
pointer. In the current example the programmer should call <code>show(nullptr)</code>
to avoid the selection of the wrong function. The <code>nullptr</code> value can also
be used to initialize pointer variables. E.g.,
        <pre>
    int *ip = nullptr;      // OK
    int value = nullptr;    // error: value is no pointer
</pre>
<p>
<a name="l19"></a>
<h3>2.5.7: The `void' parameter list</h3>
        In <strong>C</strong>, a function prototype with an <a name="an87"></a>empty parameter list, such as
        <pre>
    void func();
</pre>
 means that the argument list of the declared function is not prototyped: the
compiler does  warn against calling <code>func</code> with any set of arguments. In
<strong>C</strong> the keyword <a name="an88"></a><code>void</code> is used when it is the explicit intent to declare a
function with no arguments at all, as in:
        <pre>
    void func(void);
</pre>
    As <strong>C++</strong> enforces strict type checking, in <strong>C++</strong> an empty parameter
list indicates the <em>total absence</em> of parameters. The keyword <code>void</code> is
thus omitted.
<p>
<a name="l20"></a>
<h3>2.5.8: The `#define __cplusplus'</h3>
        Each <strong>C++</strong> compiler which conforms to the <a name="an89"></a>ANSI/ISO standard defines the
symbol <a name="an90"></a><code>__cplusplus</code>: it is as if each source file were prefixed with the
<a name="an91"></a>preprocessor directive <a name="an92"></a><code>#define __cplusplus</code>.
<p>
We shall see examples of the usage of this symbol in the following sections.
<p>
<a name="l21"></a>
<h3>2.5.9: Using standard C functions</h3>
        Normal <strong>C</strong> functions, e.g., which are compiled and collected in a run-time
library, can also be used in <strong>C++</strong> programs. Such functions, however, must be
declared as <strong>C</strong> functions.
<p>
As an example, the following code fragment declares a function <code>xmalloc</code>
as a <strong>C</strong> function:
        <pre>
    extern "C" void *xmalloc(int size);
</pre>
    This declaration is analogous to a declaration in <strong>C</strong>, except that the
prototype is prefixed with <a name="an93"></a><code>extern "C"</code>.
<p>
A slightly different way to declare <strong>C</strong> functions is the following:
        <pre>
    extern "C"
    {
        // C-declarations go in here
    }
</pre>
    It is also possible to place preprocessor directives at the location of
the declarations. E.g., a <strong>C</strong> header file <code>myheader.h</code> which declares
<strong>C</strong> functions can be included in a <strong>C++</strong> source file as follows:
        <pre>
    extern "C"
    {
        #include &lt;myheader.h&gt;
    }
</pre>
    Although these two approaches may be used, they are actually seldom
encountered in <strong>C++</strong> sources. A more frequently used method to declare
external <strong>C</strong> functions is encountered in the next section.
<p>
<a name="CHeaders"></a><a name="l22"></a>
<h3>2.5.10: Header files for both C and C++</h3>
        The combination of the predefined symbol <a name="an94"></a><code>__cplusplus</code> and the
possibility to define <a name="an95"></a><code>extern "C"</code> functions offers the ability to
create header files for both <strong>C</strong> and <strong>C++</strong>. Such a header file might,
e.g., declare a group of functions which are to be used in both <strong>C</strong> and
<strong>C++</strong> programs.
<p>
The setup of such a header file is as follows:
        <pre>
    #ifdef __cplusplus
    extern "C"
    {
    #endif

        /* declaration of C-data and functions are inserted here. E.g., */
        void *xmalloc(int size);

    #ifdef __cplusplus
    }
    #endif
</pre>
 Using this setup, a normal <strong>C</strong> header file is enclosed by <code>extern "C"</code>
<code>{</code> which occurs near the top of the file and by <code>}</code>, which occurs near
the bottom of the file. The <a name="an96"></a><code>#ifdef</code> directives test for the type of the
compilation: <strong>C</strong> or <strong>C++</strong>. The `standard' <strong>C</strong> header files, such as
<a name="an97"></a><code>stdio.h</code>, are built in this manner and are therefore usable for both <strong>C</strong>
and <strong>C++</strong>.
<p>
In addition <strong>C++</strong> headers should support <a name="an98"></a><em>include guard</em><em>s</em>.
In <strong>C++</strong> it is usually undesirable to include the same header file twice in
the same source file. Such multiple inclusions can easily be avoided by
including an <a name="an99"></a><code>#ifndef</code> directive in the header file.  For example:
        <pre>
    #ifndef MYHEADER_H_
    #define MYHEADER_H_
        // declarations of the header file is inserted here,
        // using #ifdef __cplusplus etc. directives
    #endif
</pre>
 When this file is initially scanned by the preprocessor, the symbol
<code>MYHEADER_H_</code> is not yet defined. The <code>#ifndef</code> condition succeeds and all
declarations are scanned. In addition, the symbol <code>MYHEADER_H_</code> is defined.
<p>
When this file is scanned next while compiling the same source file,
the symbol <code>MYHEADER_H_</code> has been defined and consequently all information
between the <code>#ifndef</code> and <code>#endif</code> directives is skipped by the compiler.
<p>
In this context the symbol name <code>MYHEADER_H_</code> serves only for
recognition purposes. E.g., the name of the header file can be used for this
purpose, in capitals, with an underscore character instead of a dot.
<p>
Apart from all this, the custom has evolved to give <strong>C</strong> header files the
extension <a name="an100"></a><code>.h</code>, and to give <code>C++</code> header files <em>no</em> extension. For
example, the standard <em>iostreams</em> <code>cin, cout</code> and <code>cerr</code> are available
after including the header file <a name="an101"></a><code>iostream</code>, rather
than <a name="an102"></a><code>iostream.h</code>. In the Annotations this convention is used
with the standard <strong>C++</strong> header files, but not necessarily everywhere else.
<p>
There is more to be said about header files. Section <a href="cplusplus07.html#CLASSHEADER">7.11</a> provides
an in-depth discussion of the preferred organization of <strong>C++</strong> header files.
<p>
<a name="LOCALVARS"></a><a name="l23"></a>
<h3>2.5.11: Defining local variables</h3>
        In <strong>C</strong> <a name="an103"></a>local variables can only be defined at the top of a function or at
the beginning of a nested block. In <strong>C++</strong> local variables can be created at
any position in the code, even between statements.
<p>
Furthermore, local variables can be defined within some statements, just prior
to their usage. A typical example is the <code>for</code> statement:
        <pre>
    #include &lt;stdio.h&gt;

    int main()
    {
        for (int i = 0; i &lt; 20; ++i)
            printf("%d\n", i);
    }
</pre>
    In this program the variable <code>i</code> is created in the initialization
section of the <code>for</code> statement. According to the ANSI-standard, the variable
does not exist prior to the <code>for</code>-statement and not beyond the
<code>for</code>-statement.  With some older compilers, the variable continues to exist
after the execution of the <code>for</code>-statement, but nowadays a warning like
        <blockquote>
    warning: <a name="an104"></a>name lookup of `i' changed for new ANSI `for' scoping
    using <a name="an105"></a>obsolete binding at `i'
        </blockquote>
    is issued when the variable is used outside of the <code>for</code>-loop.
<p>
The implication seems clear: define a variable just before the
<code>for</code>-statement if it is to be used beyond that statement. Otherwise the
variable should be defined inside the <code>for</code>-statement itself. This reduces
its scope as much as possible, which is a very desirable characteristic.
<p>
Defining <a name="an106"></a>local variables when they're needed requires a little getting used
to. However, eventually it tends to produce more readable, maintainable and
often more efficient code than defining variables at the beginning of compound
statements. We suggest the following rules <a name="an107"></a> of thumb for
defining local variables:
    <ul>
    <li> Local variables should be created at `intuitively right' places, such
as in the example above. This does not only entail the <code>for</code>-statement, but
also all situations where a variable is only needed, say, half-way through the
function.
    <li> More in general, variables should be defined in such a way that their
scope is as <em>limited</em> and <em>localized</em> as possible.  When avoidable local
variables are not defined at the beginning of functions but rather where
they're first used.
    <li> It is considered good practice to <a name="an108"></a>
    <a name="an109"></a><em>avoid global variables</em>. It is fairly easy to lose track of which
global variable is used for what purpose. In <strong>C++</strong> global variables are
seldom required, and by localizing variables the well known phenomenon of
using the same variable for multiple purposes, thereby invalidating each
individual purpose of the variable, can easily be prevented.
    </ul>
<p>
If considered appropriate, <a name="an110"></a><em>nested blocks</em> can be used to localize
auxiliary variables. However, situations exist where local variables are
considered appropriate inside nested statements. The just mentioned <code>for</code>
statement is of course a case in point, but local variables can also be
defined within the condition clauses of <code>if-else</code> statements, within
selection clauses of <code>switch</code> statements and condition clauses of <code>while</code>
statements. Variables thus defined are available to the full
statement, including its nested statements. For example, consider the
following <code>switch</code> statement:
        <pre>
    #include &lt;stdio.h&gt;

    int main()
    {
        switch (int c = getchar())
        {
            case 'a':
            case 'e':
            case 'i':
            case 'o':
            case 'u':
                printf("Saw vowel %c\n", c);
            break;

            case EOF:
                printf("Saw EOF\n");
            break;

            default:
                printf("Saw other character, hex value 0x%2x\n", c);
        }
    }
</pre>
    Note the location of the definition of the character `<code>c</code>': it is
defined in the expression part of the <code>switch</code> statement. This implies
that `<code>c</code>' is available <em>only</em> to the <code>switch</code> statement itself,
including its nested (sub)statements, but not outside the scope of the
<code>switch</code>.
<p>
The same approach can be used with <code>if</code> and <code>while</code> statements: a
variable that is defined in the condition part of an <code>if</code> and <code>while</code>
statement is available in their nested statements. There are some caveats,
though:
    <ul>
    <li> The variable definition must result in a variable which is
initialized to a numeric or logical value;
    <li> The variable definition cannot be nested (e.g., using parentheses)
within a more complex expression.
    </ul>
    The latter point of attention should come as no big surprise: in order to
be able to evaluate the logical condition of an <code>if</code> or <code>while</code> statement,
the value of the variable must be interpretable as either zero (false) or
non-zero (true). Usually this is no problem, but in <strong>C++</strong> <em>objects</em> (like
objects of the type <code>std::string</code> (cf. chapter <a href="cplusplus05.html#String">5</a>)) are often
returned by functions. Such objects may or may not be interpretable as numeric
values. If not (as is the case with <code>std::string</code> objects), then such
variables can <em>not</em> be defined at the condition or expression clauses of
condition- or repetition statements. The following example will therefore
<em>not</em> compile:
        <pre>
    if (std::string myString = getString())     // assume getString returns
    {                                           // a std::string value
        // process myString
    }
</pre>
<p>
The above example requires additional clarification. Often a variable can
profitably be given local scope, but an extra check is required immediately
following its initialization. The initialization <em>and</em> the test cannot
<em>both</em> be combined in one expression. Instead <em>two</em> nested statements are
required. Consequently, the following example won't compile either:
        <pre>
    if ((int c = getchar()) &amp;&amp; strchr("aeiou", c))
        printf("Saw a vowel\n");
</pre>
    If such a situation occurs, either use two nested <code>if</code> statements, or
localize the definition of <code>int c</code> using a nested compound statement:
        <pre>
    if (int c = getchar())             // nested if-statements
        if (strchr("aeiou", c))
            printf("Saw a vowel\n");

    {                                  // nested compound statement
        int c = getchar();
        if (c &amp;&amp; strchr("aeiou", c))
           printf("Saw a vowel\n");
    }
</pre>
<p>
<a name="l24"></a>
<h3>2.5.12: The keyword `typedef'</h3>
        The keyword <a name="an111"></a><code>typedef</code> is still used in <strong>C++</strong>, but is not required
anymore when defining  <a name="an112"></a><code>union</code>, <a name="an113"></a><code>struct</code> or <a name="an114"></a><code>enum</code> definitions.
This is illustrated in the following example:
        <pre>
    struct SomeStruct
    {
        int     a;
        double  d;
        char    string[80];
    };
</pre>
    When a <code>struct, union</code> or other compound type is defined, the tag of
this type can be used as type name (this is <code>SomeStruct</code> in the above
example):
        <pre>
    SomeStruct what;

    what.d = 3.1415;
</pre>
<p>
<a name="FunctionInStruct"></a><a name="l25"></a>
<h3>2.5.13: Functions as part of a struct</h3>
        In <strong>C++</strong> we may define <a name="an115"></a>functions as members of structs. Here we
encounter the first concrete example of an object: as previously described
(see section <a href="cplusplus02.html#OOP">2.4</a>), an <a name="an116"></a>object is a structure containing data while
specialized functions exist to manipulate those data.
<p>
A definition of a <code>struct Point</code> is provided by the code fragment below.
In this structure, two <code>int</code> data fields and one function <code>draw</code> are
declared.
        <pre>
    struct Point            // definition of a screen-dot
    {
        int x;              // coordinates
        int y;              // x/y
        void draw();        // drawing function
    };
</pre>
    A similar structure could be part of a painting program and could, e.g.,
represent a pixel. With respect to this <code>struct</code> it should be noted that:
    <ul>
    <li> The function <code>draw</code> mentioned in the <code>struct</code> definition is a
mere <em>declaration</em>. The actual code of the function defining the actions
performed by the function is found elsewhere (the concept of functions inside
<code>struct</code>s is further discussed in section <a href="cplusplus03.html#FunctionsInStructs">3.2</a>).
    <li> The size of the <code>struct</code> <code>Point</code> is equal to the size of its
two <code>int</code>s.  A function declared inside the structure does not affect its
size. The compiler implements this behavior by allowing the function
<code>draw</code> to be available only in the context of a <code>Point</code>.
    </ul>
    The <code>Point</code> structure could be used as follows:
        <pre>
    Point a;                // two points on
    Point b;                // the screen

    a.x = 0;                // define first dot
    a.y = 10;               // and draw it
    a.draw();

    b = a;                  // copy a to b
    b.y = 20;               // redefine y-coord
    b.draw();               // and draw it
</pre>
    As shown in the above example a function that is part of the structure may
be selected using the dot (.) (the arrow (<code>-&gt;</code>) operator is used when
pointers to objects are available). This is therefore identical to the way
data fields of structures are selected.
<p>
The idea behind this syntactic construction is that several types may
contain <a name="an117"></a>functions having identical names. E.g., a structure representing a
circle might contain three <code>int</code> values: two values for the coordinates of
the center of the circle and one value for the radius. Analogously to the
<code>Point</code> structure, a <code>Circle</code> may now have a function <code>draw</code> to draw the
circle.
<p>

<hr>
<ul>
    <li> <a href="cplusplus.html">Table of Contents</a>
    <li> <a href="cplusplus01.html">Previous Chapter</a>
    <li> <a href="cplusplus03.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
