*git.txt*       Git manual on vim doc.

Git                                                                     *git*

    Introduction        |git-introduction|
    Installation        |git-installation|
    Usage               |git-usage|
    Commands            |git-commands|
        add             |git-add|
        bisect          |git-bisect|
        branch          |git-branch|
        checkout        |git-checkout|
        clone           |git-clone|
        commit          |git-commit|
        diff            |git-diff|
        fetch           |git-fetch|
        grep            |git-grep|
        init            |git-init|
        log             |git-log|
        merge           |git-merge|
        mv              |git-mv|
        pull            |git-pull|
        push            |git-push|
        rebase          |git-rebase|
        reset           |git-reset|
        rm              |git-rm|
        show            |git-show|
        status          |git-status|
        tag             |git-tag|
    Tips                |git-tips|
    About               |git-about|

==============================================================================
INTRODUCTION                                                *git-introduction*

git - the stupid content tracker

Git is a fast, scalable, distributed revision control system with an
unusually rich command set that provides both high-level operations
and full access to internals.

See linkgit:gittutorial[7] to get started, then see
link:everyday.html[Everyday Git] for a useful minimum set of commands, and
"man git-commandname" for documentation of each command.  CVS users may
also want to read linkgit:gitcvs-migration[7].  See
the link:user-manual.html[Git User's Manual] for a more in-depth
introduction.

The COMMAND is either a name of a Git command (see below) or an alias
as defined in the configuration file (see linkgit:git-config[1]).

Formatted and hyperlinked version of the latest git
documentation can be viewed at
`http://www.kernel.org/pub/software/scm/git/docs/`.


==============================================================================
INSTALLATION                                                *git-installation*


==============================================================================
USAGE                                                             *git-usage*

usage: git [--version] [--exec-path[=GIT_EXEC_PATH]] [--html-path]
           [-p|--paginate|--no-pager] [--no-replace-objects]
           [--bare] [--git-dir=GIT_DIR] [--work-tree=GIT_WORK_TREE]
           [--help] COMMAND [ARGS]


==============================================================================
COMMANDS                                                        *git-commands*

The most commonly used git commands are:
   add        Add file contents to the index
   bisect     Find by binary search the change that introduced a bug
   branch     List, create, or delete branches
   checkout   Checkout a branch or paths to the working tree
   clone      Clone a repository into a new directory
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   fetch      Download objects and refs from another repository
   grep       Print lines matching a pattern
   init       Create an empty git repository or reinitialize an existing one
   log        Show commit logs
   merge      Join two or more development histories together
   mv         Move or rename a file, a directory, or a symlink
   pull       Fetch from and merge with another repository or a local branch
   push       Update remote refs along with associated objects
   rebase     Forward-port local commits to the updated upstream head
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index
   show       Show various types of objects
   status     Show the working tree status
   tag        Create, list, delete or verify a tag object signed with GPG

See 'git help COMMAND' for more information on a specific command.


------------------------------------------------------------------------------
ADD                                                                  *git-add*

git-add - Add file contents to the index

SYNOPSIS
--------
[verse]
'git add' [-n] [-v] [--force | -f] [--interactive | -i] [--patch | -p]
	  [--edit | -e] [--all | [--update | -u]] [--intent-to-add | -N]
	  [--refresh] [--ignore-errors] [--] [<filepattern>...]

This command updates the index using the current content found in
the working tree, to prepare the content staged for the next commit.
It typically adds the current content of existing paths as a whole,
but with some options it can also be used to add content with
only part of the changes made to the working tree files applied, or
remove paths that do not exist in the working tree anymore.

The "index" holds a snapshot of the content of the working tree, and it
is this snapshot that is taken as the contents of the next commit.  Thus
after making any changes to the working directory, and before running
the commit command, you must use the `add` command to add any new or
modified files to the index.

This command can be performed multiple times before a commit.  It only
adds the content of the specified file(s) at the time the add command is
run; if you want subsequent changes included in the next commit, then
you must run `git add` again to add the new content to the index.

The `git status` command can be used to obtain a summary of which
files have changes that are staged for the next commit.

The `git add` command will not add ignored files by default.  If any
ignored files were explicitly specified on the command line, `git add`
will fail with a list of ignored files.  Ignored files reached by
directory recursion or filename globbing performed by Git (quote your
globs before the shell) will be silently ignored.  The 'git add' command can
be used to add ignored files with the `-f` (force) option.

Please see linkgit:git-commit[1] for alternative ways to add content to a
commit.


OPTIONS
-------

<filepattern>...::
	Files to add content from.  Fileglobs (e.g. `*.c`) can
	be given to add all matching files.  Also a
	leading directory name (e.g. `dir` to add `dir/file1`
	and `dir/file2`) can be given to add all files in the
	directory, recursively.

-n::
--dry-run::
        Don't actually add the file(s), just show if they exist.

-v::
--verbose::
        Be verbose.

-f::
--force::
	Allow adding otherwise ignored files.

-i::
--interactive::
	Add modified contents in the working tree interactively to
	the index. Optional path arguments may be supplied to limit
	operation to a subset of the working tree. See ``Interactive
	mode'' for details.

-p::
--patch::
	Interactively choose hunks of patch between the index and the
	work tree and add them to the index. This gives the user a chance
	to review the difference before adding modified contents to the
	index.
+
This effectively runs `add --interactive`, but bypasses the
initial command menu and directly jumps to the `patch` subcommand.
See ``Interactive mode'' for details.

-e, \--edit::
	Open the diff vs. the index in an editor and let the user
	edit it.  After the editor was closed, adjust the hunk headers
	and apply the patch to the index.
+
*NOTE*: Obviously, if you change anything else than the first character
on lines beginning with a space or a minus, the patch will no longer
apply.

-u::
--update::
	Only match <filepattern> against already tracked files in
	the index rather than the working tree. That means that it
	will never stage new files, but that it will stage modified
	new contents of tracked files and that it will remove files
	from the index if the corresponding files in the working tree
	have been removed.
+
If no <filepattern> is given, default to "."; in other words,
update all tracked files in the current directory and its
subdirectories.

-A::
--all::
	Like `-u`, but match <filepattern> against files in the
	working tree in addition to the index. That means that it
	will find new files as well as staging modified content and
	removing files that are no longer in the working tree.

-N::
--intent-to-add::
	Record only the fact that the path will be added later. An entry
	for the path is placed in the index with no content. This is
	useful for, among other things, showing the unstaged content of
	such files with `git diff` and committing them with `git commit
	-a`.

--refresh::
	Don't add the file(s), but only refresh their stat()
	information in the index.

--ignore-errors::
	If some files could not be added because of errors indexing
	them, do not abort the operation, but continue adding the
	others. The command shall still exit with non-zero status.

\--::
	This option can be used to separate command-line options from
	the list of files, (useful when filenames might be mistaken
	for command-line options).


Configuration
-------------

The optional configuration variable `core.excludesfile` indicates a path to a
file containing patterns of file names to exclude from git-add, similar to
$GIT_DIR/info/exclude.  Patterns in the exclude file are used in addition to
those in info/exclude.  See linkgit:gitrepository-layout[5].


EXAMPLES
--------

* Adds content from all `\*.txt` files under `Documentation` directory
and its subdirectories:
+
>
    $ git add Documentation/\*.txt
<
+
Note that the asterisk `\*` is quoted from the shell in this
example; this lets the command include the files from
subdirectories of `Documentation/` directory.

* Considers adding content from all git-*.sh scripts:
+
>
    $ git add git-*.sh
<
+
Because this example lets the shell expand the asterisk (i.e. you are
listing the files explicitly), it does not consider
`subdir/git-foo.sh`.

Interactive mode
----------------
When the command enters the interactive mode, it shows the
output of the 'status' subcommand, and then goes into its
interactive command loop.

The command loop shows the list of subcommands available, and
gives a prompt "What now> ".  In general, when the prompt ends
with a single '>', you can pick only one of the choices given
and type return, like this:

>
    *** Commands ***
      1: status       2: update       3: revert       4: add untracked
      5: patch        6: diff         7: quit         8: help
    What now> 1
<

You also could say `s` or `sta` or `status` above as long as the
choice is unique.

The main command loop has 6 subcommands (plus help and quit).

status::

   This shows the change between HEAD and index (i.e. what will be
   committed if you say `git commit`), and between index and
   working tree files (i.e. what you could stage further before
   `git commit` using `git add`) for each path.  A sample output
   looks like this:
+
>
              staged     unstaged path
     1:       binary      nothing foo.png
     2:     +403/-35        +1/-1 git-add--interactive.perl
<
+
It shows that foo.png has differences from HEAD (but that is
binary so line count cannot be shown) and there is no
difference between indexed copy and the working tree
version (if the working tree version were also different,
'binary' would have been shown in place of 'nothing').  The
other file, git-add--interactive.perl, has 403 lines added
and 35 lines deleted if you commit what is in the index, but
working tree file has further modifications (one addition and
one deletion).

update::

   This shows the status information and issues an "Update>>"
   prompt.  When the prompt ends with double '>>', you can
   make more than one selection, concatenated with whitespace or
   comma.  Also you can say ranges.  E.g. "2-5 7,9" to choose
   2,3,4,5,7,9 from the list.  If the second number in a range is
   omitted, all remaining patches are taken.  E.g. "7-" to choose
   7,8,9 from the list.  You can say '*' to choose everything.
+
What you chose are then highlighted with '*',
like this:
+
>
               staged     unstaged path
      1:       binary      nothing foo.png
    * 2:     +403/-35        +1/-1 git-add--interactive.perl
<
+
To remove selection, prefix the input with `-`
like this:
+
>
    Update>> -2
<
+
After making the selection, answer with an empty line to stage the
contents of working tree files for selected paths in the index.

revert::

  This has a very similar UI to 'update', and the staged
  information for selected paths are reverted to that of the
  HEAD version.  Reverting new paths makes them untracked.

add untracked::

  This has a very similar UI to 'update' and
  'revert', and lets you add untracked paths to the index.

patch::

  This lets you choose one path out of a 'status' like selection.
  After choosing the path, it presents the diff between the index
  and the working tree file and asks you if you want to stage
  the change of each hunk.  You can say:

       y - stage this hunk
       n - do not stage this hunk
       q - quit, do not stage this hunk nor any of the remaining ones
       a - stage this and all the remaining hunks in the file
       d - do not stage this hunk nor any of the remaining hunks in the file
       g - select a hunk to go to
       / - search for a hunk matching the given regex
       j - leave this hunk undecided, see next undecided hunk
       J - leave this hunk undecided, see next hunk
       k - leave this hunk undecided, see previous undecided hunk
       K - leave this hunk undecided, see previous hunk
       s - split the current hunk into smaller hunks
       e - manually edit the current hunk
       ? - print help
+
After deciding the fate for all hunks, if there is any hunk
that was chosen, the index is updated with the selected hunks.

diff::

  This lets you review what will be committed (i.e. between
  HEAD and index).

SEE ALSO
--------
|git-status|, |git-rm|, |git-reset|, |git-mv|, |git-commit|, |git-update-index|

Author
------
Written by Linus Torvalds <torvalds@osdl.org>

Documentation
--------------
Documentation by Junio C Hamano and the git-list <git@vger.kernel.org>.

GIT
---
Part of the |git| suite


------------------------------------------------------------------------------
BISECT                                                        *git-bisect*

git-bisect - Find by binary search the change that introduced a bug

SYNOPSIS
--------
'git bisect' <subcommand> <options>

DESCRIPTION
-----------
The command takes various subcommands, and different options depending
on the subcommand:

 git bisect help
 git bisect start [<bad> [<good>...]] [--] [<paths>...]
 git bisect bad [<rev>]
 git bisect good [<rev>...]
 git bisect skip [(<rev>|<range>)...]
 git bisect reset [<commit>]
 git bisect visualize
 git bisect replay <logfile>
 git bisect log
 git bisect run <cmd>...

This command uses 'git rev-list --bisect' to help drive the
binary search process to find which change introduced a bug, given an
old "good" commit object name and a later "bad" commit object name.

Getting help
~~~~~~~~~~~~

Use "git bisect" to get a short usage description, and "git bisect
help" or "git bisect -h" to get a long usage description.

Basic bisect commands: start, bad, good
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Using the Linux kernel tree as an example, basic use of the bisect
command is as follows:

>
    $ git bisect start
    $ git bisect bad                 # Current version is bad
    $ git bisect good v2.6.13-rc2    # v2.6.13-rc2 was the last version
                                 # tested that was good
<

When you have specified at least one bad and one good version, the
command bisects the revision tree and outputs something similar to
the following:

>
    Bisecting: 675 revisions left to test after this
<

The state in the middle of the set of revisions is then checked out.
You would now compile that kernel and boot it. If the booted kernel
works correctly, you would then issue the following command:

>
    $ git bisect good			# this one is good
<

The output of this command would be something similar to the following:

>
    Bisecting: 337 revisions left to test after this
<

You keep repeating this process, compiling the tree, testing it, and
depending on whether it is good or bad issuing the command "git bisect good"
or "git bisect bad" to ask for the next bisection.

Eventually there will be no more revisions left to bisect, and you
will have been left with the first bad kernel revision in "refs/bisect/bad".

Bisect reset
~~~~~~~~~~~~

After a bisect session, to clean up the bisection state and return to
the original HEAD, issue the following command:

>
    $ git bisect reset
<

By default, this will return your tree to the commit that was checked
out before `git bisect start`.  (A new `git bisect start` will also do
that, as it cleans up the old bisection state.)

With an optional argument, you can return to a different commit
instead:

>
    $ git bisect reset <commit>
<

For example, `git bisect reset HEAD` will leave you on the current
bisection commit and avoid switching commits at all, while `git bisect
reset bisect/bad` will check out the first bad revision.

Bisect visualize
~~~~~~~~~~~~~~~~

To see the currently remaining suspects in 'gitk', issue the following
command during the bisection process:

>
    $ git bisect visualize
<

`view` may also be used as a synonym for `visualize`.

If the 'DISPLAY' environment variable is not set, 'git log' is used
instead.  You can also give command line options such as `-p` and
`--stat`.

>
    $ git bisect view --stat
<

Bisect log and bisect replay
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After having marked revisions as good or bad, issue the following
command to show what has been done so far:

>
    $ git bisect log
<

If you discover that you made a mistake in specifying the status of a
revision, you can save the output of this command to a file, edit it to
remove the incorrect entries, and then issue the following commands to
return to a corrected state:

>
    $ git bisect reset
    $ git bisect replay that-file
<

Avoiding testing a commit
~~~~~~~~~~~~~~~~~~~~~~~~~

If, in the middle of a bisect session, you know that the next suggested
revision is not a good one to test (e.g. the change the commit
introduces is known not to work in your environment and you know it
does not have anything to do with the bug you are chasing), you may
want to find a nearby commit and try that instead.

For example:

>
    $ git bisect good/bad			# previous round was good or bad.
    Bisecting: 337 revisions left to test after this
    $ git bisect visualize			# oops, that is uninteresting.
    $ git reset --hard HEAD~3		# try 3 revisions before what
                                            # was suggested
<

Then compile and test the chosen revision, and afterwards mark
the revision as good or bad in the usual manner.

Bisect skip
~~~~~~~~~~~~

Instead of choosing by yourself a nearby commit, you can ask git
to do it for you by issuing the command:

>
    $ git bisect skip                 # Current version cannot be tested
<

But git may eventually be unable to tell the first bad commit among
a bad commit and one or more skipped commits.

You can even skip a range of commits, instead of just one commit,
using the "'<commit1>'..'<commit2>'" notation. For example:

>
    $ git bisect skip v2.5..v2.6
<

This tells the bisect process that no commit after `v2.5`, up to and
including `v2.6`, should be tested.

Note that if you also want to skip the first commit of the range you
would issue the command:

>
    $ git bisect skip v2.5 v2.5..v2.6
<

This tells the bisect process that the commits between `v2.5` included
and `v2.6` included should be skipped.


Cutting down bisection by giving more parameters to bisect start
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can further cut down the number of trials, if you know what part of
the tree is involved in the problem you are tracking down, by specifying
path parameters when issuing the `bisect start` command:

>
    $ git bisect start -- arch/i386 include/asm-i386
<

If you know beforehand more than one good commit, you can narrow the
bisect space down by specifying all of the good commits immediately after
the bad commit when issuing the `bisect start` command:

>
    $ git bisect start v2.6.20-rc6 v2.6.20-rc4 v2.6.20-rc1 --
                       # v2.6.20-rc6 is bad
                       # v2.6.20-rc4 and v2.6.20-rc1 are good
<

Bisect run
~~~~~~~~~~

If you have a script that can tell if the current source code is good
or bad, you can bisect by issuing the command:

>
    $ git bisect run my_script arguments
<

Note that the script (`my_script` in the above example) should
exit with code 0 if the current source code is good, and exit with a
code between 1 and 127 (inclusive), except 125, if the current
source code is bad.

Any other exit code will abort the bisect process. It should be noted
that a program that terminates via "exit(-1)" leaves $? = 255, (see the
exit(3) manual page), as the value is chopped with "& 0377".

The special exit code 125 should be used when the current source code
cannot be tested. If the script exits with this code, the current
revision will be skipped (see `git bisect skip` above).

You may often find that during a bisect session you want to have
temporary modifications (e.g. s/#define DEBUG 0/#define DEBUG 1/ in a
header file, or "revision that does not have this commit needs this
patch applied to work around another problem this bisection is not
interested in") applied to the revision being tested.

To cope with such a situation, after the inner 'git bisect' finds the
next revision to test, the script can apply the patch
before compiling, run the real test, and afterwards decide if the
revision (possibly with the needed patch) passed the test and then
rewind the tree to the pristine state.  Finally the script should exit
with the status of the real test to let the "git bisect run" command loop
determine the eventual outcome of the bisect session.

EXAMPLES
--------

* Automatically bisect a broken build between v1.2 and HEAD:
+
>
    $ git bisect start HEAD v1.2 --      # HEAD is bad, v1.2 is good
    $ git bisect run make                # "make" builds the app
<

* Automatically bisect a test failure between origin and HEAD:
+
>
    $ git bisect start HEAD origin --    # HEAD is bad, origin is good
    $ git bisect run make test           # "make test" builds and tests
<

* Automatically bisect a broken test suite:
+
>
    $ cat ~/test.sh
    #!/bin/sh
    make || exit 125                   # this skips broken builds
    make test                          # "make test" runs the test suite
    $ git bisect start v1.3 v1.1 --    # v1.3 is bad, v1.1 is good
    $ git bisect run ~/test.sh
<
+
Here we use a "test.sh" custom script. In this script, if "make"
fails, we skip the current commit.
+
It is safer to use a custom script outside the repository to prevent
interactions between the bisect, make and test processes and the
script.
+
"make test" should "exit 0", if the test suite passes, and
"exit 1" otherwise.

* Automatically bisect a broken test case:
+
>
    $ cat ~/test.sh
    #!/bin/sh
    make || exit 125                     # this skips broken builds
    ~/check_test_case.sh                 # does the test case passes ?
    $ git bisect start HEAD HEAD~10 --   # culprit is among the last 10
    $ git bisect run ~/test.sh
<
+
Here "check_test_case.sh" should "exit 0" if the test case passes,
and "exit 1" otherwise.
+
It is safer if both "test.sh" and "check_test_case.sh" scripts are
outside the repository to prevent interactions between the bisect,
make and test processes and the scripts.

* Automatically bisect a broken test suite:
+
>
    $ git bisect start HEAD HEAD~10 --   # culprit is among the last 10
    $ git bisect run sh -c "make || exit 125; ~/check_test_case.sh"
<
+
Does the same as the previous example, but on a single line.

Author
------
Written by Linus Torvalds <torvalds@osdl.org>

Documentation
-------------
Documentation by Junio C Hamano and the git-list <git@vger.kernel.org>.

SEE ALSO
--------
link:git-bisect-lk2009.html[Fighting regressions with git bisect],
|git-blame|.


------------------------------------------------------------------------------
BRANCH                                                           *git-branch*

git-branch - List, create, or delete branches

SYNOPSIS
--------
[verse]
'git branch' [--color[=<when>] | --no-color] [-r | -a]
	[-v [--abbrev=<length> | --no-abbrev]]
	[(--merged | --no-merged | --contains) [<commit>]]
'git branch' [--set-upstream | --track | --no-track] [-l] [-f] <branchname> [<start-point>]
'git branch' (-m | -M) [<oldbranch>] <newbranch>
'git branch' (-d | -D) [-r] <branchname>...

DESCRIPTION
-----------

With no arguments, existing branches are listed and the current branch will
be highlighted with an asterisk.  Option `-r` causes the remote-tracking
branches to be listed, and option `-a` shows both.

With `--contains`, shows only the branches that contain the named commit
(in other words, the branches whose tip commits are descendants of the
named commit).  With `--merged`, only branches merged into the named
commit (i.e. the branches whose tip commits are reachable from the named
commit) will be listed.  With `--no-merged` only branches not merged into
the named commit will be listed.  If the <commit> argument is missing it
defaults to 'HEAD' (i.e. the tip of the current branch).

The command's second form creates a new branch head named <branchname>
which points to the current 'HEAD', or <start-point> if given.

Note that this will create the new branch, but it will not switch the
working tree to it; use "git checkout <newbranch>" to switch to the
new branch.

When a local branch is started off a remote branch, git sets up the
branch so that 'git pull' will appropriately merge from
the remote branch. This behavior may be changed via the global
`branch.autosetupmerge` configuration flag. That setting can be
overridden by using the `--track` and `--no-track` options.

With a '-m' or '-M' option, <oldbranch> will be renamed to <newbranch>.
If <oldbranch> had a corresponding reflog, it is renamed to match
<newbranch>, and a reflog entry is created to remember the branch
renaming. If <newbranch> exists, -M must be used to force the rename
to happen.

With a `-d` or `-D` option, `<branchname>` will be deleted.  You may
specify more than one branch for deletion.  If the branch currently
has a reflog then the reflog will also be deleted.

Use -r together with -d to delete remote-tracking branches. Note, that it
only makes sense to delete remote-tracking branches if they no longer exist
in the remote repository or if 'git fetch' was configured not to fetch
them again. See also the 'prune' subcommand of linkgit:git-remote[1] for a
way to clean up all obsolete remote-tracking branches.


OPTIONS
-------
-d::
	Delete a branch. The branch must be fully merged in HEAD.

-D::
	Delete a branch irrespective of its merged status.

-l::
	Create the branch's reflog.  This activates recording of
	all changes made to the branch ref, enabling use of date
	based sha1 expressions such as "<branchname>@\{yesterday}".

-f::
--force::
	Reset <branchname> to <startpoint> if <branchname> exists
	already. Without `-f` 'git branch' refuses to change an existing branch.

-m::
	Move/rename a branch and the corresponding reflog.

-M::
	Move/rename a branch even if the new branch name already exists.

--color[=<when>]::
	Color branches to highlight current, local, and remote branches.
	The value must be always (the default), never, or auto.

--no-color::
	Turn off branch colors, even when the configuration file gives the
	default to color output.
	Same as `--color=never`.

-r::
	List or delete (if used with -d) the remote-tracking branches.

-a::
	List both remote-tracking branches and local branches.

-v::
--verbose::
	Show sha1 and commit subject line for each head, along with
	relationship to upstream branch (if any). If given twice, print
	the name of the upstream branch, as well.

--abbrev=<length>::
	Alter the sha1's minimum display length in the output listing.
	The default value is 7.

--no-abbrev::
	Display the full sha1s in the output listing rather than abbreviating them.

-t::
--track::
	When creating a new branch, set up configuration to mark the
	start-point branch as "upstream" from the new branch. This
	configuration will tell git to show the relationship between the
	two branches in `git status` and `git branch -v`. Furthermore,
	it directs `git pull` without arguments to pull from the
	upstream when the new branch is checked out.
+
This behavior is the default when the start point is a remote branch.
Set the branch.autosetupmerge configuration variable to `false` if you
want `git checkout` and `git branch` to always behave as if '--no-track'
were given. Set it to `always` if you want this behavior when the
start-point is either a local or remote branch.

--no-track::
	Do not set up "upstream" configuration, even if the
	branch.autosetupmerge configuration variable is true.

--set-upstream::
	If specified branch does not exist yet or if '--force' has been
	given, acts exactly like '--track'. Otherwise sets up configuration
	like '--track' would when creating the branch, except that where
	branch points to is not changed.

--contains <commit>::
	Only list branches which contain the specified commit.

--merged [<commit>]::
	Only list branches whose tips are reachable from the
	specified commit (HEAD if not specified).

--no-merged [<commit>]::
	Only list branches whose tips are not reachable from the
	specified commit (HEAD if not specified).

<branchname>::
	The name of the branch to create or delete.
	The new branch name must pass all checks defined by
	linkgit:git-check-ref-format[1].  Some of these checks
	may restrict the characters allowed in a branch name.

<start-point>::
	The new branch head will point to this commit.  It may be
	given as a branch name, a commit-id, or a tag.  If this
	option is omitted, the current HEAD will be used instead.

<oldbranch>::
	The name of an existing branch to rename.

<newbranch>::
	The new name for an existing branch. The same restrictions as for
	<branchname> apply.


Examples
--------

Start development from a known tag::
+
>
    $ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6
    $ cd my2.6
    $ git branch my2.6.14 v2.6.14   <1>
    $ git checkout my2.6.14
<
+
<1> This step and the next one could be combined into a single step with
"checkout -b my2.6.14 v2.6.14".

Delete an unneeded branch::
+
>
    $ git clone git://git.kernel.org/.../git.git my.git
    $ cd my.git
    $ git branch -d -r origin/todo origin/html origin/man   <1>
    $ git branch -D test                                    <2>
<
+
<1> Delete the remote-tracking branches "todo", "html" and "man". The next
'fetch' or 'pull' will create them again unless you configure them not to.
See linkgit:git-fetch[1].
<2> Delete the "test" branch even if the "master" branch (or whichever branch
is currently checked out) does not have all commits from the test branch.


Notes
-----

If you are creating a branch that you want to checkout immediately, it is
easier to use the git checkout command with its `-b` option to create
a branch and check it out with a single command.

The options `--contains`, `--merged` and `--no-merged` serve three related
but different purposes:

- `--contains <commit>` is used to find all branches which will need
  special attention if <commit> were to be rebased or amended, since those
  branches contain the specified <commit>.

- `--merged` is used to find all branches which can be safely deleted,
  since those branches are fully contained by HEAD.

- `--no-merged` is used to find branches which are candidates for merging
  into HEAD, since those branches are not fully contained by HEAD.

SEE ALSO
--------
|git-check-ref-format|, |git-fetch|, |git-remote|,
link:user-manual.html#what-is-a-branch[``Understanding history: What is
a branch?''] in the Git User's Manual.

Author
------
Written by Linus Torvalds <torvalds@osdl.org> and Junio C Hamano <gitster@pobox.com>

Documentation
--------------
Documentation by Junio C Hamano and the git-list <git@vger.kernel.org>.


------------------------------------------------------------------------------
CHECKOUT                                                        *git-checkout*

git-checkout - Checkout a branch or paths to the working tree

SYNOPSIS
--------
[verse]
'git checkout' [-q] [-f] [-m] [<branch>]
'git checkout' [-q] [-f] [-m] [-b <new_branch>] [<start_point>]
'git checkout' [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <paths>...
'git checkout' --patch [<tree-ish>] [--] [<paths>...]

DESCRIPTION
-----------

When <paths> are not given, this command switches branches by
updating the index, working tree, and HEAD to reflect the specified
branch.

If `-b` is given, a new branch is created and checked out, as if
linkgit:git-branch[1] were called; in this case you can
use the --track or --no-track options, which will be passed to `git
branch`.  As a convenience, --track without `-b` implies branch
creation; see the description of --track below.

When <paths> or --patch are given, this command does *not* switch
branches.  It updates the named paths in the working tree from
the index file, or from a named <tree-ish> (most often a commit).  In
this case, the `-b` and `--track` options are meaningless and giving
either of them results in an error. The <tree-ish> argument can be
used to specify a specific tree-ish (i.e. commit, tag or tree)
to update the index for the given paths before updating the
working tree.

The index may contain unmerged entries after a failed merge.  By
default, if you try to check out such an entry from the index, the
checkout operation will fail and nothing will be checked out.
Using -f will ignore these unmerged entries.  The contents from a
specific side of the merge can be checked out of the index by
using --ours or --theirs.  With -m, changes made to the working tree
file can be discarded to recreate the original conflicted merge result.

OPTIONS
-------
-q::
--quiet::
	Quiet, suppress feedback messages.

-f::
--force::
	When switching branches, proceed even if the index or the
	working tree differs from HEAD.  This is used to throw away
	local changes.
+
When checking out paths from the index, do not fail upon unmerged
entries; instead, unmerged entries are ignored.

--ours::
--theirs::
	When checking out paths from the index, check out stage #2
	('ours') or #3 ('theirs') for unmerged paths.

-b::
	Create a new branch named <new_branch> and start it at
	<start_point>; see linkgit:git-branch[1] for details.

-t::
--track::
	When creating a new branch, set up "upstream" configuration. See
	"--track" in linkgit:git-branch[1] for details.
+
If no '-b' option is given, the name of the new branch will be
derived from the remote branch.  If "remotes/" or "refs/remotes/"
is prefixed it is stripped away, and then the part up to the
next slash (which would be the nickname of the remote) is removed.
This would tell us to use "hack" as the local branch when branching
off of "origin/hack" (or "remotes/origin/hack", or even
"refs/remotes/origin/hack").  If the given name has no slash, or the above
guessing results in an empty name, the guessing is aborted.  You can
explicitly give a name with '-b' in such a case.

--no-track::
	Do not set up "upstream" configuration, even if the
	branch.autosetupmerge configuration variable is true.

-l::
	Create the new branch's reflog; see linkgit:git-branch[1] for
	details.

-m::
--merge::
	When switching branches,
	if you have local modifications to one or more files that
	are different between the current branch and the branch to
	which you are switching, the command refuses to switch
	branches in order to preserve your modifications in context.
	However, with this option, a three-way merge between the current
	branch, your working tree contents, and the new branch
	is done, and you will be on the new branch.
+
When a merge conflict happens, the index entries for conflicting
paths are left unmerged, and you need to resolve the conflicts
and mark the resolved paths with `git add` (or `git rm` if the merge
should result in deletion of the path).
+
When checking out paths from the index, this option lets you recreate
the conflicted merge in the specified paths.

--conflict=<style>::
	The same as --merge option above, but changes the way the
	conflicting hunks are presented, overriding the
	merge.conflictstyle configuration variable.  Possible values are
	"merge" (default) and "diff3" (in addition to what is shown by
	"merge" style, shows the original contents).

-p::
--patch::
	Interactively select hunks in the difference between the
	<tree-ish> (or the index, if unspecified) and the working
	tree.  The chosen hunks are then applied in reverse to the
	working tree (and if a <tree-ish> was specified, the index).
+
This means that you can use `git checkout -p` to selectively discard
edits from your current working tree.

<branch>::
	Branch to checkout; if it refers to a branch (i.e., a name that,
	when prepended with "refs/heads/", is a valid ref), then that
	branch is checked out. Otherwise, if it refers to a valid
	commit, your HEAD becomes "detached" and you are no longer on
	any branch (see below for details).
+
As a special case, the `"@\{-N\}"` syntax for the N-th last branch
checks out the branch (instead of detaching).  You may also specify
`-` which is synonymous with `"@\{-1\}"`.

<new_branch>::
	Name for the new branch.

<start_point>::
	The name of a commit at which to start the new branch; see
	linkgit:git-branch[1] for details. Defaults to HEAD.

<tree-ish>::
	Tree to checkout from (when paths are given). If not specified,
	the index will be used.



Detached HEAD
-------------

It is sometimes useful to be able to 'checkout' a commit that is
not at the tip of one of your branches.  The most obvious
example is to check out the commit at a tagged official release
point, like this:

>
    $ git checkout v2.6.18
<

Earlier versions of git did not allow this and asked you to
create a temporary branch using the `-b` option, but starting from
version 1.5.0, the above command 'detaches' your HEAD from the
current branch and directly points at the commit named by the tag
(`v2.6.18` in the example above).

You can use all git commands while in this state.  You can use
`git reset --hard $othercommit` to further move around, for
example.  You can make changes and create a new commit on top of
a detached HEAD.  You can even create a merge by using `git
merge $othercommit`.

The state you are in while your HEAD is detached is not recorded
by any branch (which is natural --- you are not on any branch).
What this means is that you can discard your temporary commits
and merges by switching back to an existing branch (e.g. `git
checkout master`), and a later `git prune` or `git gc` would
garbage-collect them.  If you did this by mistake, you can ask
the reflog for HEAD where you were, e.g.

>
    $ git log -g -2 HEAD
<


EXAMPLES
--------

. The following sequence checks out the `master` branch, reverts
the `Makefile` to two revisions back, deletes hello.c by
mistake, and gets it back from the index.
+
>
    $ git checkout master             <1>
    $ git checkout master~2 Makefile  <2>
    $ rm -f hello.c
    $ git checkout hello.c            <3>
<
+
<1> switch branch
<2> take a file out of another commit
<3> restore hello.c from the index
+
If you have an unfortunate branch that is named `hello.c`, this
step would be confused as an instruction to switch to that branch.
You should instead write:
+
>
    $ git checkout -- hello.c
<

. After working in the wrong branch, switching to the correct
branch would be done using:
+
>
    $ git checkout mytopic
<
+
However, your "wrong" branch and correct "mytopic" branch may
differ in files that you have modified locally, in which case
the above checkout would fail like this:
+
>
    $ git checkout mytopic
    fatal: Entry 'frotz' not uptodate. Cannot merge.
<
+
You can give the `-m` flag to the command, which would try a
three-way merge:
+
>
    $ git checkout -m mytopic
    Auto-merging frotz
<
+
After this three-way merge, the local modifications are _not_
registered in your index file, so `git diff` would show you what
changes you made since the tip of the new branch.

. When a merge conflict happens during switching branches with
the `-m` option, you would see something like this:
+
>
    $ git checkout -m mytopic
    Auto-merging frotz
    ERROR: Merge conflict in frotz
    fatal: merge program failed
<
+
At this point, `git diff` shows the changes cleanly merged as in
the previous example, as well as the changes in the conflicted
files.  Edit and resolve the conflict and mark it resolved with
`git add` as usual:
+
>
    $ edit frotz
    $ git add frotz
<


Author
------
Written by Linus Torvalds <torvalds@osdl.org>

Documentation
--------------
Documentation by Junio C Hamano and the git-list <git@vger.kernel.org>.


------------------------------------------------------------------------------
        clone                                                   *git-clone*

------------------------------------------------------------------------------
        commit                                                  *git-commit*

------------------------------------------------------------------------------
        diff                                                    *git-diff*

------------------------------------------------------------------------------
        fetch                                                   *git-fetch*

------------------------------------------------------------------------------
        grep                                                    *git-grep*

------------------------------------------------------------------------------
        init                                                    *git-init*

------------------------------------------------------------------------------
        log                                                     *git-log*

------------------------------------------------------------------------------
        merge                                                   *git-merge*

------------------------------------------------------------------------------
        mv                                                      *git-mv*

------------------------------------------------------------------------------
        pull                                                    *git-pull*

------------------------------------------------------------------------------
        push                                                    *git-push*

------------------------------------------------------------------------------
        rebase                                                  *git-rebase*

------------------------------------------------------------------------------
        reset                                                   *git-reset*

------------------------------------------------------------------------------
        rm                                                      *git-rm*

------------------------------------------------------------------------------
        show                                                    *git-show*

------------------------------------------------------------------------------
        status                                                  *git-status*

------------------------------------------------------------------------------
        tag                                                     *git-tag*


==============================================================================
TIPS                                                                *git-tips*

您可以补充自己的小 tips 到这里。


==============================================================================
ABOUT                                                              *git-about*

This document is from Git manual.
by 闲耘™(hotoo.cn[AT]gmail.com)

 vim:tw=78:ts=8:ft=help
